/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dotenv";
exports.ids = ["vendor-chunks/dotenv"];
exports.modules = {

/***/ "(rsc)/./node_modules/dotenv/lib/main.js":
/*!*****************************************!*\
  !*** ./node_modules/dotenv/lib/main.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\")\r\nconst path = __webpack_require__(/*! path */ \"path\")\r\nconst os = __webpack_require__(/*! os */ \"os\")\r\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\")\r\nconst packageJson = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/dotenv/package.json\")\r\n\r\nconst version = packageJson.version\r\n\r\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\r\n\r\n// Parse src into an Object\r\nfunction parse (src) {\r\n  const obj = {}\r\n\r\n  // Convert buffer to string\r\n  let lines = src.toString()\r\n\r\n  // Convert line breaks to same format\r\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\r\n\r\n  let match\r\n  while ((match = LINE.exec(lines)) != null) {\r\n    const key = match[1]\r\n\r\n    // Default undefined or null to empty string\r\n    let value = (match[2] || '')\r\n\r\n    // Remove whitespace\r\n    value = value.trim()\r\n\r\n    // Check if double quoted\r\n    const maybeQuote = value[0]\r\n\r\n    // Remove surrounding quotes\r\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\r\n\r\n    // Expand newlines if double quoted\r\n    if (maybeQuote === '\"') {\r\n      value = value.replace(/\\\\n/g, '\\n')\r\n      value = value.replace(/\\\\r/g, '\\r')\r\n    }\r\n\r\n    // Add to object\r\n    obj[key] = value\r\n  }\r\n\r\n  return obj\r\n}\r\n\r\nfunction _parseVault (options) {\r\n  const vaultPath = _vaultPath(options)\r\n\r\n  // Parse .env.vault\r\n  const result = DotenvModule.configDotenv({ path: vaultPath })\r\n  if (!result.parsed) {\r\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\r\n    err.code = 'MISSING_DATA'\r\n    throw err\r\n  }\r\n\r\n  // handle scenario for comma separated keys - for use with key rotation\r\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\r\n  const keys = _dotenvKey(options).split(',')\r\n  const length = keys.length\r\n\r\n  let decrypted\r\n  for (let i = 0; i < length; i++) {\r\n    try {\r\n      // Get full key\r\n      const key = keys[i].trim()\r\n\r\n      // Get instructions for decrypt\r\n      const attrs = _instructions(result, key)\r\n\r\n      // Decrypt\r\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\r\n\r\n      break\r\n    } catch (error) {\r\n      // last key\r\n      if (i + 1 >= length) {\r\n        throw error\r\n      }\r\n      // try next key\r\n    }\r\n  }\r\n\r\n  // Parse decrypted .env string\r\n  return DotenvModule.parse(decrypted)\r\n}\r\n\r\nfunction _log (message) {\r\n  console.log(`[dotenv@${version}][INFO] ${message}`)\r\n}\r\n\r\nfunction _warn (message) {\r\n  console.log(`[dotenv@${version}][WARN] ${message}`)\r\n}\r\n\r\nfunction _debug (message) {\r\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\r\n}\r\n\r\nfunction _dotenvKey (options) {\r\n  // prioritize developer directly setting options.DOTENV_KEY\r\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\r\n    return options.DOTENV_KEY\r\n  }\r\n\r\n  // secondary infra already contains a DOTENV_KEY environment variable\r\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\r\n    return process.env.DOTENV_KEY\r\n  }\r\n\r\n  // fallback to empty string\r\n  return ''\r\n}\r\n\r\nfunction _instructions (result, dotenvKey) {\r\n  // Parse DOTENV_KEY. Format is a URI\r\n  let uri\r\n  try {\r\n    uri = new URL(dotenvKey)\r\n  } catch (error) {\r\n    if (error.code === 'ERR_INVALID_URL') {\r\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\r\n      err.code = 'INVALID_DOTENV_KEY'\r\n      throw err\r\n    }\r\n\r\n    throw error\r\n  }\r\n\r\n  // Get decrypt key\r\n  const key = uri.password\r\n  if (!key) {\r\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\r\n    err.code = 'INVALID_DOTENV_KEY'\r\n    throw err\r\n  }\r\n\r\n  // Get environment\r\n  const environment = uri.searchParams.get('environment')\r\n  if (!environment) {\r\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\r\n    err.code = 'INVALID_DOTENV_KEY'\r\n    throw err\r\n  }\r\n\r\n  // Get ciphertext payload\r\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\r\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\r\n  if (!ciphertext) {\r\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\r\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\r\n    throw err\r\n  }\r\n\r\n  return { ciphertext, key }\r\n}\r\n\r\nfunction _vaultPath (options) {\r\n  let possibleVaultPath = null\r\n\r\n  if (options && options.path && options.path.length > 0) {\r\n    if (Array.isArray(options.path)) {\r\n      for (const filepath of options.path) {\r\n        if (fs.existsSync(filepath)) {\r\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\r\n        }\r\n      }\r\n    } else {\r\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\r\n    }\r\n  } else {\r\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\r\n  }\r\n\r\n  if (fs.existsSync(possibleVaultPath)) {\r\n    return possibleVaultPath\r\n  }\r\n\r\n  return null\r\n}\r\n\r\nfunction _resolveHome (envPath) {\r\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\r\n}\r\n\r\nfunction _configVault (options) {\r\n  _log('Loading env from encrypted .env.vault')\r\n\r\n  const parsed = DotenvModule._parseVault(options)\r\n\r\n  let processEnv = process.env\r\n  if (options && options.processEnv != null) {\r\n    processEnv = options.processEnv\r\n  }\r\n\r\n  DotenvModule.populate(processEnv, parsed, options)\r\n\r\n  return { parsed }\r\n}\r\n\r\nfunction configDotenv (options) {\r\n  const dotenvPath = path.resolve(process.cwd(), '.env')\r\n  let encoding = 'utf8'\r\n  const debug = Boolean(options && options.debug)\r\n\r\n  if (options && options.encoding) {\r\n    encoding = options.encoding\r\n  } else {\r\n    if (debug) {\r\n      _debug('No encoding is specified. UTF-8 is used by default')\r\n    }\r\n  }\r\n\r\n  let optionPaths = [dotenvPath] // default, look for .env\r\n  if (options && options.path) {\r\n    if (!Array.isArray(options.path)) {\r\n      optionPaths = [_resolveHome(options.path)]\r\n    } else {\r\n      optionPaths = [] // reset default\r\n      for (const filepath of options.path) {\r\n        optionPaths.push(_resolveHome(filepath))\r\n      }\r\n    }\r\n  }\r\n\r\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\r\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\r\n  let lastError\r\n  const parsedAll = {}\r\n  for (const path of optionPaths) {\r\n    try {\r\n      // Specifying an encoding returns a string instead of a buffer\r\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\r\n\r\n      DotenvModule.populate(parsedAll, parsed, options)\r\n    } catch (e) {\r\n      if (debug) {\r\n        _debug(`Failed to load ${path} ${e.message}`)\r\n      }\r\n      lastError = e\r\n    }\r\n  }\r\n\r\n  let processEnv = process.env\r\n  if (options && options.processEnv != null) {\r\n    processEnv = options.processEnv\r\n  }\r\n\r\n  DotenvModule.populate(processEnv, parsedAll, options)\r\n\r\n  if (lastError) {\r\n    return { parsed: parsedAll, error: lastError }\r\n  } else {\r\n    return { parsed: parsedAll }\r\n  }\r\n}\r\n\r\n// Populates process.env from .env file\r\nfunction config (options) {\r\n  // fallback to original dotenv if DOTENV_KEY is not set\r\n  if (_dotenvKey(options).length === 0) {\r\n    return DotenvModule.configDotenv(options)\r\n  }\r\n\r\n  const vaultPath = _vaultPath(options)\r\n\r\n  // dotenvKey exists but .env.vault file does not exist\r\n  if (!vaultPath) {\r\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\r\n\r\n    return DotenvModule.configDotenv(options)\r\n  }\r\n\r\n  return DotenvModule._configVault(options)\r\n}\r\n\r\nfunction decrypt (encrypted, keyStr) {\r\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\r\n  let ciphertext = Buffer.from(encrypted, 'base64')\r\n\r\n  const nonce = ciphertext.subarray(0, 12)\r\n  const authTag = ciphertext.subarray(-16)\r\n  ciphertext = ciphertext.subarray(12, -16)\r\n\r\n  try {\r\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\r\n    aesgcm.setAuthTag(authTag)\r\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\r\n  } catch (error) {\r\n    const isRange = error instanceof RangeError\r\n    const invalidKeyLength = error.message === 'Invalid key length'\r\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\r\n\r\n    if (isRange || invalidKeyLength) {\r\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\r\n      err.code = 'INVALID_DOTENV_KEY'\r\n      throw err\r\n    } else if (decryptionFailed) {\r\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\r\n      err.code = 'DECRYPTION_FAILED'\r\n      throw err\r\n    } else {\r\n      throw error\r\n    }\r\n  }\r\n}\r\n\r\n// Populate process.env with parsed values\r\nfunction populate (processEnv, parsed, options = {}) {\r\n  const debug = Boolean(options && options.debug)\r\n  const override = Boolean(options && options.override)\r\n\r\n  if (typeof parsed !== 'object') {\r\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\r\n    err.code = 'OBJECT_REQUIRED'\r\n    throw err\r\n  }\r\n\r\n  // Set process.env\r\n  for (const key of Object.keys(parsed)) {\r\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\r\n      if (override === true) {\r\n        processEnv[key] = parsed[key]\r\n      }\r\n\r\n      if (debug) {\r\n        if (override === true) {\r\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\r\n        } else {\r\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\r\n        }\r\n      }\r\n    } else {\r\n      processEnv[key] = parsed[key]\r\n    }\r\n  }\r\n}\r\n\r\nconst DotenvModule = {\r\n  configDotenv,\r\n  _configVault,\r\n  _parseVault,\r\n  config,\r\n  decrypt,\r\n  parse,\r\n  populate\r\n}\r\n\r\nmodule.exports.configDotenv = DotenvModule.configDotenv\r\nmodule.exports._configVault = DotenvModule._configVault\r\nmodule.exports._parseVault = DotenvModule._parseVault\r\nmodule.exports.config = DotenvModule.config\r\nmodule.exports.decrypt = DotenvModule.decrypt\r\nmodule.exports.parse = DotenvModule.parse\r\nmodule.exports.populate = DotenvModule.populate\r\n\r\nmodule.exports = DotenvModule\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG90ZW52L2xpYi9tYWluLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsaUVBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQ7QUFDQSx3REFBd0QsV0FBVztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUSxVQUFVLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVEsVUFBVSxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRLFdBQVcsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDBCQUEwQjtBQUNuRTtBQUNBO0FBQ0EscUZBQXFGLGdCQUFnQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsU0FBUztBQUNuRjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDhFQUE4RSxhQUFhO0FBQzNGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFVBQVU7QUFDMUU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGlDQUFpQyxNQUFNLEVBQUUsVUFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsVUFBVTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQixFQUFFLGVBQWU7QUFDekQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSTtBQUN6QixVQUFVO0FBQ1YscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Z1c2lvbi1haS8uL25vZGVfbW9kdWxlcy9kb3RlbnYvbGliL21haW4uanM/NzVhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxyXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJylcclxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcclxuY29uc3QgcGFja2FnZUpzb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKVxyXG5cclxuY29uc3QgdmVyc2lvbiA9IHBhY2thZ2VKc29uLnZlcnNpb25cclxuXHJcbmNvbnN0IExJTkUgPSAvKD86XnxeKVxccyooPzpleHBvcnRcXHMrKT8oW1xcdy4tXSspKD86XFxzKj1cXHMqP3w6XFxzKz8pKFxccyonKD86XFxcXCd8W14nXSkqJ3xcXHMqXCIoPzpcXFxcXCJ8W15cIl0pKlwifFxccypgKD86XFxcXGB8W15gXSkqYHxbXiNcXHJcXG5dKyk/XFxzKig/OiMuKik/KD86JHwkKS9tZ1xyXG5cclxuLy8gUGFyc2Ugc3JjIGludG8gYW4gT2JqZWN0XHJcbmZ1bmN0aW9uIHBhcnNlIChzcmMpIHtcclxuICBjb25zdCBvYmogPSB7fVxyXG5cclxuICAvLyBDb252ZXJ0IGJ1ZmZlciB0byBzdHJpbmdcclxuICBsZXQgbGluZXMgPSBzcmMudG9TdHJpbmcoKVxyXG5cclxuICAvLyBDb252ZXJ0IGxpbmUgYnJlYWtzIHRvIHNhbWUgZm9ybWF0XHJcbiAgbGluZXMgPSBsaW5lcy5yZXBsYWNlKC9cXHJcXG4/L21nLCAnXFxuJylcclxuXHJcbiAgbGV0IG1hdGNoXHJcbiAgd2hpbGUgKChtYXRjaCA9IExJTkUuZXhlYyhsaW5lcykpICE9IG51bGwpIHtcclxuICAgIGNvbnN0IGtleSA9IG1hdGNoWzFdXHJcblxyXG4gICAgLy8gRGVmYXVsdCB1bmRlZmluZWQgb3IgbnVsbCB0byBlbXB0eSBzdHJpbmdcclxuICAgIGxldCB2YWx1ZSA9IChtYXRjaFsyXSB8fCAnJylcclxuXHJcbiAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZVxyXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKClcclxuXHJcbiAgICAvLyBDaGVjayBpZiBkb3VibGUgcXVvdGVkXHJcbiAgICBjb25zdCBtYXliZVF1b3RlID0gdmFsdWVbMF1cclxuXHJcbiAgICAvLyBSZW1vdmUgc3Vycm91bmRpbmcgcXVvdGVzXHJcbiAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14oWydcImBdKShbXFxzXFxTXSopXFwxJC9tZywgJyQyJylcclxuXHJcbiAgICAvLyBFeHBhbmQgbmV3bGluZXMgaWYgZG91YmxlIHF1b3RlZFxyXG4gICAgaWYgKG1heWJlUXVvdGUgPT09ICdcIicpIHtcclxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcclxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcci9nLCAnXFxyJylcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdG8gb2JqZWN0XHJcbiAgICBvYmpba2V5XSA9IHZhbHVlXHJcbiAgfVxyXG5cclxuICByZXR1cm4gb2JqXHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9wYXJzZVZhdWx0IChvcHRpb25zKSB7XHJcbiAgY29uc3QgdmF1bHRQYXRoID0gX3ZhdWx0UGF0aChvcHRpb25zKVxyXG5cclxuICAvLyBQYXJzZSAuZW52LnZhdWx0XHJcbiAgY29uc3QgcmVzdWx0ID0gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudih7IHBhdGg6IHZhdWx0UGF0aCB9KVxyXG4gIGlmICghcmVzdWx0LnBhcnNlZCkge1xyXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBNSVNTSU5HX0RBVEE6IENhbm5vdCBwYXJzZSAke3ZhdWx0UGF0aH0gZm9yIGFuIHVua25vd24gcmVhc29uYClcclxuICAgIGVyci5jb2RlID0gJ01JU1NJTkdfREFUQSdcclxuICAgIHRocm93IGVyclxyXG4gIH1cclxuXHJcbiAgLy8gaGFuZGxlIHNjZW5hcmlvIGZvciBjb21tYSBzZXBhcmF0ZWQga2V5cyAtIGZvciB1c2Ugd2l0aCBrZXkgcm90YXRpb25cclxuICAvLyBleGFtcGxlOiBET1RFTlZfS0VZPVwiZG90ZW52Oi8vOmtleV8xMjM0QGRvdGVudnguY29tL3ZhdWx0Ly5lbnYudmF1bHQ/ZW52aXJvbm1lbnQ9cHJvZCxkb3RlbnY6Ly86a2V5Xzc4OTBAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1wcm9kXCJcclxuICBjb25zdCBrZXlzID0gX2RvdGVudktleShvcHRpb25zKS5zcGxpdCgnLCcpXHJcbiAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGhcclxuXHJcbiAgbGV0IGRlY3J5cHRlZFxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEdldCBmdWxsIGtleVxyXG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldLnRyaW0oKVxyXG5cclxuICAgICAgLy8gR2V0IGluc3RydWN0aW9ucyBmb3IgZGVjcnlwdFxyXG4gICAgICBjb25zdCBhdHRycyA9IF9pbnN0cnVjdGlvbnMocmVzdWx0LCBrZXkpXHJcblxyXG4gICAgICAvLyBEZWNyeXB0XHJcbiAgICAgIGRlY3J5cHRlZCA9IERvdGVudk1vZHVsZS5kZWNyeXB0KGF0dHJzLmNpcGhlcnRleHQsIGF0dHJzLmtleSlcclxuXHJcbiAgICAgIGJyZWFrXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAvLyBsYXN0IGtleVxyXG4gICAgICBpZiAoaSArIDEgPj0gbGVuZ3RoKSB7XHJcbiAgICAgICAgdGhyb3cgZXJyb3JcclxuICAgICAgfVxyXG4gICAgICAvLyB0cnkgbmV4dCBrZXlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFBhcnNlIGRlY3J5cHRlZCAuZW52IHN0cmluZ1xyXG4gIHJldHVybiBEb3RlbnZNb2R1bGUucGFyc2UoZGVjcnlwdGVkKVxyXG59XHJcblxyXG5mdW5jdGlvbiBfbG9nIChtZXNzYWdlKSB7XHJcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV1bSU5GT10gJHttZXNzYWdlfWApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIF93YXJuIChtZXNzYWdlKSB7XHJcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV1bV0FSTl0gJHttZXNzYWdlfWApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9kZWJ1ZyAobWVzc2FnZSkge1xyXG4gIGNvbnNvbGUubG9nKGBbZG90ZW52QCR7dmVyc2lvbn1dW0RFQlVHXSAke21lc3NhZ2V9YClcclxufVxyXG5cclxuZnVuY3Rpb24gX2RvdGVudktleSAob3B0aW9ucykge1xyXG4gIC8vIHByaW9yaXRpemUgZGV2ZWxvcGVyIGRpcmVjdGx5IHNldHRpbmcgb3B0aW9ucy5ET1RFTlZfS0VZXHJcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ET1RFTlZfS0VZICYmIG9wdGlvbnMuRE9URU5WX0tFWS5sZW5ndGggPiAwKSB7XHJcbiAgICByZXR1cm4gb3B0aW9ucy5ET1RFTlZfS0VZXHJcbiAgfVxyXG5cclxuICAvLyBzZWNvbmRhcnkgaW5mcmEgYWxyZWFkeSBjb250YWlucyBhIERPVEVOVl9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGVcclxuICBpZiAocHJvY2Vzcy5lbnYuRE9URU5WX0tFWSAmJiBwcm9jZXNzLmVudi5ET1RFTlZfS0VZLmxlbmd0aCA+IDApIHtcclxuICAgIHJldHVybiBwcm9jZXNzLmVudi5ET1RFTlZfS0VZXHJcbiAgfVxyXG5cclxuICAvLyBmYWxsYmFjayB0byBlbXB0eSBzdHJpbmdcclxuICByZXR1cm4gJydcclxufVxyXG5cclxuZnVuY3Rpb24gX2luc3RydWN0aW9ucyAocmVzdWx0LCBkb3RlbnZLZXkpIHtcclxuICAvLyBQYXJzZSBET1RFTlZfS0VZLiBGb3JtYXQgaXMgYSBVUklcclxuICBsZXQgdXJpXHJcbiAgdHJ5IHtcclxuICAgIHVyaSA9IG5ldyBVUkwoZG90ZW52S2V5KVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ0VSUl9JTlZBTElEX1VSTCcpIHtcclxuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IFdyb25nIGZvcm1hdC4gTXVzdCBiZSBpbiB2YWxpZCB1cmkgZm9ybWF0IGxpa2UgZG90ZW52Oi8vOmtleV8xMjM0QGRvdGVudnguY29tL3ZhdWx0Ly5lbnYudmF1bHQ/ZW52aXJvbm1lbnQ9ZGV2ZWxvcG1lbnQnKVxyXG4gICAgICBlcnIuY29kZSA9ICdJTlZBTElEX0RPVEVOVl9LRVknXHJcbiAgICAgIHRocm93IGVyclxyXG4gICAgfVxyXG5cclxuICAgIHRocm93IGVycm9yXHJcbiAgfVxyXG5cclxuICAvLyBHZXQgZGVjcnlwdCBrZXlcclxuICBjb25zdCBrZXkgPSB1cmkucGFzc3dvcmRcclxuICBpZiAoIWtleSkge1xyXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IE1pc3Npbmcga2V5IHBhcnQnKVxyXG4gICAgZXJyLmNvZGUgPSAnSU5WQUxJRF9ET1RFTlZfS0VZJ1xyXG4gICAgdGhyb3cgZXJyXHJcbiAgfVxyXG5cclxuICAvLyBHZXQgZW52aXJvbm1lbnRcclxuICBjb25zdCBlbnZpcm9ubWVudCA9IHVyaS5zZWFyY2hQYXJhbXMuZ2V0KCdlbnZpcm9ubWVudCcpXHJcbiAgaWYgKCFlbnZpcm9ubWVudCkge1xyXG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IE1pc3NpbmcgZW52aXJvbm1lbnQgcGFydCcpXHJcbiAgICBlcnIuY29kZSA9ICdJTlZBTElEX0RPVEVOVl9LRVknXHJcbiAgICB0aHJvdyBlcnJcclxuICB9XHJcblxyXG4gIC8vIEdldCBjaXBoZXJ0ZXh0IHBheWxvYWRcclxuICBjb25zdCBlbnZpcm9ubWVudEtleSA9IGBET1RFTlZfVkFVTFRfJHtlbnZpcm9ubWVudC50b1VwcGVyQ2FzZSgpfWBcclxuICBjb25zdCBjaXBoZXJ0ZXh0ID0gcmVzdWx0LnBhcnNlZFtlbnZpcm9ubWVudEtleV0gLy8gRE9URU5WX1ZBVUxUX1BST0RVQ1RJT05cclxuICBpZiAoIWNpcGhlcnRleHQpIHtcclxuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgTk9UX0ZPVU5EX0RPVEVOVl9FTlZJUk9OTUVOVDogQ2Fubm90IGxvY2F0ZSBlbnZpcm9ubWVudCAke2Vudmlyb25tZW50S2V5fSBpbiB5b3VyIC5lbnYudmF1bHQgZmlsZS5gKVxyXG4gICAgZXJyLmNvZGUgPSAnTk9UX0ZPVU5EX0RPVEVOVl9FTlZJUk9OTUVOVCdcclxuICAgIHRocm93IGVyclxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgY2lwaGVydGV4dCwga2V5IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3ZhdWx0UGF0aCAob3B0aW9ucykge1xyXG4gIGxldCBwb3NzaWJsZVZhdWx0UGF0aCA9IG51bGxcclxuXHJcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoICYmIG9wdGlvbnMucGF0aC5sZW5ndGggPiAwKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGgpKSB7XHJcbiAgICAgIGZvciAoY29uc3QgZmlsZXBhdGggb2Ygb3B0aW9ucy5wYXRoKSB7XHJcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZmlsZXBhdGgpKSB7XHJcbiAgICAgICAgICBwb3NzaWJsZVZhdWx0UGF0aCA9IGZpbGVwYXRoLmVuZHNXaXRoKCcudmF1bHQnKSA/IGZpbGVwYXRoIDogYCR7ZmlsZXBhdGh9LnZhdWx0YFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcG9zc2libGVWYXVsdFBhdGggPSBvcHRpb25zLnBhdGguZW5kc1dpdGgoJy52YXVsdCcpID8gb3B0aW9ucy5wYXRoIDogYCR7b3B0aW9ucy5wYXRofS52YXVsdGBcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcG9zc2libGVWYXVsdFBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJy5lbnYudmF1bHQnKVxyXG4gIH1cclxuXHJcbiAgaWYgKGZzLmV4aXN0c1N5bmMocG9zc2libGVWYXVsdFBhdGgpKSB7XHJcbiAgICByZXR1cm4gcG9zc2libGVWYXVsdFBhdGhcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsXHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9yZXNvbHZlSG9tZSAoZW52UGF0aCkge1xyXG4gIHJldHVybiBlbnZQYXRoWzBdID09PSAnficgPyBwYXRoLmpvaW4ob3MuaG9tZWRpcigpLCBlbnZQYXRoLnNsaWNlKDEpKSA6IGVudlBhdGhcclxufVxyXG5cclxuZnVuY3Rpb24gX2NvbmZpZ1ZhdWx0IChvcHRpb25zKSB7XHJcbiAgX2xvZygnTG9hZGluZyBlbnYgZnJvbSBlbmNyeXB0ZWQgLmVudi52YXVsdCcpXHJcblxyXG4gIGNvbnN0IHBhcnNlZCA9IERvdGVudk1vZHVsZS5fcGFyc2VWYXVsdChvcHRpb25zKVxyXG5cclxuICBsZXQgcHJvY2Vzc0VudiA9IHByb2Nlc3MuZW52XHJcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wcm9jZXNzRW52ICE9IG51bGwpIHtcclxuICAgIHByb2Nlc3NFbnYgPSBvcHRpb25zLnByb2Nlc3NFbnZcclxuICB9XHJcblxyXG4gIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwcm9jZXNzRW52LCBwYXJzZWQsIG9wdGlvbnMpXHJcblxyXG4gIHJldHVybiB7IHBhcnNlZCB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbmZpZ0RvdGVudiAob3B0aW9ucykge1xyXG4gIGNvbnN0IGRvdGVudlBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJy5lbnYnKVxyXG4gIGxldCBlbmNvZGluZyA9ICd1dGY4J1xyXG4gIGNvbnN0IGRlYnVnID0gQm9vbGVhbihvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpXHJcblxyXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcpIHtcclxuICAgIGVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZ1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoZGVidWcpIHtcclxuICAgICAgX2RlYnVnKCdObyBlbmNvZGluZyBpcyBzcGVjaWZpZWQuIFVURi04IGlzIHVzZWQgYnkgZGVmYXVsdCcpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBsZXQgb3B0aW9uUGF0aHMgPSBbZG90ZW52UGF0aF0gLy8gZGVmYXVsdCwgbG9vayBmb3IgLmVudlxyXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGF0aCkge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMucGF0aCkpIHtcclxuICAgICAgb3B0aW9uUGF0aHMgPSBbX3Jlc29sdmVIb21lKG9wdGlvbnMucGF0aCldXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBvcHRpb25QYXRocyA9IFtdIC8vIHJlc2V0IGRlZmF1bHRcclxuICAgICAgZm9yIChjb25zdCBmaWxlcGF0aCBvZiBvcHRpb25zLnBhdGgpIHtcclxuICAgICAgICBvcHRpb25QYXRocy5wdXNoKF9yZXNvbHZlSG9tZShmaWxlcGF0aCkpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJ1aWxkIHRoZSBwYXJzZWQgZGF0YSBpbiBhIHRlbXBvcmFyeSBvYmplY3QgKGJlY2F1c2Ugd2UgbmVlZCB0byByZXR1cm4gaXQpLiAgT25jZSB3ZSBoYXZlIHRoZSBmaW5hbFxyXG4gIC8vIHBhcnNlZCBkYXRhLCB3ZSB3aWxsIGNvbWJpbmUgaXQgd2l0aCBwcm9jZXNzLmVudiAob3Igb3B0aW9ucy5wcm9jZXNzRW52IGlmIHByb3ZpZGVkKS5cclxuICBsZXQgbGFzdEVycm9yXHJcbiAgY29uc3QgcGFyc2VkQWxsID0ge31cclxuICBmb3IgKGNvbnN0IHBhdGggb2Ygb3B0aW9uUGF0aHMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFNwZWNpZnlpbmcgYW4gZW5jb2RpbmcgcmV0dXJucyBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgYnVmZmVyXHJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IERvdGVudk1vZHVsZS5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aCwgeyBlbmNvZGluZyB9KSlcclxuXHJcbiAgICAgIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwYXJzZWRBbGwsIHBhcnNlZCwgb3B0aW9ucylcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgaWYgKGRlYnVnKSB7XHJcbiAgICAgICAgX2RlYnVnKGBGYWlsZWQgdG8gbG9hZCAke3BhdGh9ICR7ZS5tZXNzYWdlfWApXHJcbiAgICAgIH1cclxuICAgICAgbGFzdEVycm9yID0gZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbGV0IHByb2Nlc3NFbnYgPSBwcm9jZXNzLmVudlxyXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJvY2Vzc0VudiAhPSBudWxsKSB7XHJcbiAgICBwcm9jZXNzRW52ID0gb3B0aW9ucy5wcm9jZXNzRW52XHJcbiAgfVxyXG5cclxuICBEb3RlbnZNb2R1bGUucG9wdWxhdGUocHJvY2Vzc0VudiwgcGFyc2VkQWxsLCBvcHRpb25zKVxyXG5cclxuICBpZiAobGFzdEVycm9yKSB7XHJcbiAgICByZXR1cm4geyBwYXJzZWQ6IHBhcnNlZEFsbCwgZXJyb3I6IGxhc3RFcnJvciB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB7IHBhcnNlZDogcGFyc2VkQWxsIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIFBvcHVsYXRlcyBwcm9jZXNzLmVudiBmcm9tIC5lbnYgZmlsZVxyXG5mdW5jdGlvbiBjb25maWcgKG9wdGlvbnMpIHtcclxuICAvLyBmYWxsYmFjayB0byBvcmlnaW5hbCBkb3RlbnYgaWYgRE9URU5WX0tFWSBpcyBub3Qgc2V0XHJcbiAgaWYgKF9kb3RlbnZLZXkob3B0aW9ucykubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudihvcHRpb25zKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgdmF1bHRQYXRoID0gX3ZhdWx0UGF0aChvcHRpb25zKVxyXG5cclxuICAvLyBkb3RlbnZLZXkgZXhpc3RzIGJ1dCAuZW52LnZhdWx0IGZpbGUgZG9lcyBub3QgZXhpc3RcclxuICBpZiAoIXZhdWx0UGF0aCkge1xyXG4gICAgX3dhcm4oYFlvdSBzZXQgRE9URU5WX0tFWSBidXQgeW91IGFyZSBtaXNzaW5nIGEgLmVudi52YXVsdCBmaWxlIGF0ICR7dmF1bHRQYXRofS4gRGlkIHlvdSBmb3JnZXQgdG8gYnVpbGQgaXQ/YClcclxuXHJcbiAgICByZXR1cm4gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudihvcHRpb25zKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIERvdGVudk1vZHVsZS5fY29uZmlnVmF1bHQob3B0aW9ucylcclxufVxyXG5cclxuZnVuY3Rpb24gZGVjcnlwdCAoZW5jcnlwdGVkLCBrZXlTdHIpIHtcclxuICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShrZXlTdHIuc2xpY2UoLTY0KSwgJ2hleCcpXHJcbiAgbGV0IGNpcGhlcnRleHQgPSBCdWZmZXIuZnJvbShlbmNyeXB0ZWQsICdiYXNlNjQnKVxyXG5cclxuICBjb25zdCBub25jZSA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgMTIpXHJcbiAgY29uc3QgYXV0aFRhZyA9IGNpcGhlcnRleHQuc3ViYXJyYXkoLTE2KVxyXG4gIGNpcGhlcnRleHQgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDEyLCAtMTYpXHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBhZXNnY20gPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTI1Ni1nY20nLCBrZXksIG5vbmNlKVxyXG4gICAgYWVzZ2NtLnNldEF1dGhUYWcoYXV0aFRhZylcclxuICAgIHJldHVybiBgJHthZXNnY20udXBkYXRlKGNpcGhlcnRleHQpfSR7YWVzZ2NtLmZpbmFsKCl9YFxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zdCBpc1JhbmdlID0gZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yXHJcbiAgICBjb25zdCBpbnZhbGlkS2V5TGVuZ3RoID0gZXJyb3IubWVzc2FnZSA9PT0gJ0ludmFsaWQga2V5IGxlbmd0aCdcclxuICAgIGNvbnN0IGRlY3J5cHRpb25GYWlsZWQgPSBlcnJvci5tZXNzYWdlID09PSAnVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJ1xyXG5cclxuICAgIGlmIChpc1JhbmdlIHx8IGludmFsaWRLZXlMZW5ndGgpIHtcclxuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IEl0IG11c3QgYmUgNjQgY2hhcmFjdGVycyBsb25nIChvciBtb3JlKScpXHJcbiAgICAgIGVyci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX0tFWSdcclxuICAgICAgdGhyb3cgZXJyXHJcbiAgICB9IGVsc2UgaWYgKGRlY3J5cHRpb25GYWlsZWQpIHtcclxuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdERUNSWVBUSU9OX0ZBSUxFRDogUGxlYXNlIGNoZWNrIHlvdXIgRE9URU5WX0tFWScpXHJcbiAgICAgIGVyci5jb2RlID0gJ0RFQ1JZUFRJT05fRkFJTEVEJ1xyXG4gICAgICB0aHJvdyBlcnJcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBQb3B1bGF0ZSBwcm9jZXNzLmVudiB3aXRoIHBhcnNlZCB2YWx1ZXNcclxuZnVuY3Rpb24gcG9wdWxhdGUgKHByb2Nlc3NFbnYsIHBhcnNlZCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgY29uc3QgZGVidWcgPSBCb29sZWFuKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZylcclxuICBjb25zdCBvdmVycmlkZSA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLm92ZXJyaWRlKVxyXG5cclxuICBpZiAodHlwZW9mIHBhcnNlZCAhPT0gJ29iamVjdCcpIHtcclxuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignT0JKRUNUX1JFUVVJUkVEOiBQbGVhc2UgY2hlY2sgdGhlIHByb2Nlc3NFbnYgYXJndW1lbnQgYmVpbmcgcGFzc2VkIHRvIHBvcHVsYXRlJylcclxuICAgIGVyci5jb2RlID0gJ09CSkVDVF9SRVFVSVJFRCdcclxuICAgIHRocm93IGVyclxyXG4gIH1cclxuXHJcbiAgLy8gU2V0IHByb2Nlc3MuZW52XHJcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyc2VkKSkge1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9jZXNzRW52LCBrZXkpKSB7XHJcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHByb2Nlc3NFbnZba2V5XSA9IHBhcnNlZFtrZXldXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChkZWJ1Zykge1xyXG4gICAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgX2RlYnVnKGBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgV0FTIG92ZXJ3cml0dGVuYClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgX2RlYnVnKGBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgd2FzIE5PVCBvdmVyd3JpdHRlbmApXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcm9jZXNzRW52W2tleV0gPSBwYXJzZWRba2V5XVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuY29uc3QgRG90ZW52TW9kdWxlID0ge1xyXG4gIGNvbmZpZ0RvdGVudixcclxuICBfY29uZmlnVmF1bHQsXHJcbiAgX3BhcnNlVmF1bHQsXHJcbiAgY29uZmlnLFxyXG4gIGRlY3J5cHQsXHJcbiAgcGFyc2UsXHJcbiAgcG9wdWxhdGVcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMuY29uZmlnRG90ZW52ID0gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudlxyXG5tb2R1bGUuZXhwb3J0cy5fY29uZmlnVmF1bHQgPSBEb3RlbnZNb2R1bGUuX2NvbmZpZ1ZhdWx0XHJcbm1vZHVsZS5leHBvcnRzLl9wYXJzZVZhdWx0ID0gRG90ZW52TW9kdWxlLl9wYXJzZVZhdWx0XHJcbm1vZHVsZS5leHBvcnRzLmNvbmZpZyA9IERvdGVudk1vZHVsZS5jb25maWdcclxubW9kdWxlLmV4cG9ydHMuZGVjcnlwdCA9IERvdGVudk1vZHVsZS5kZWNyeXB0XHJcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gRG90ZW52TW9kdWxlLnBhcnNlXHJcbm1vZHVsZS5leHBvcnRzLnBvcHVsYXRlID0gRG90ZW52TW9kdWxlLnBvcHVsYXRlXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERvdGVudk1vZHVsZVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/dotenv/lib/main.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/dotenv/package.json":
/*!******************************************!*\
  !*** ./node_modules/dotenv/package.json ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"dotenv","version":"16.4.5","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","lint-readme":"standard-markdown","pretest":"npm run lint && npm run dts-check","test":"tap tests/*.js --100 -Rspec","test:coverage":"tap --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@definitelytyped/dtslint":"^0.0.133","@types/node":"^18.11.3","decache":"^4.6.1","sinon":"^14.0.1","standard":"^17.0.0","standard-markdown":"^7.1.0","standard-version":"^9.5.0","tap":"^16.3.0","tar":"^6.1.11","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}');

/***/ })

};
;