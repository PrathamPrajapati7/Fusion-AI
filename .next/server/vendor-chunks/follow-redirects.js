/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/follow-redirects";
exports.ids = ["vendor-chunks/follow-redirects"];
exports.modules = {

/***/ "(ssr)/./node_modules/follow-redirects/debug.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/debug.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var debug;\r\n\r\nmodule.exports = function () {\r\n  if (!debug) {\r\n    try {\r\n      /* eslint global-require: off */\r\n      debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\")(\"follow-redirects\");\r\n    }\r\n    catch (error) { /* */ }\r\n    if (typeof debug !== \"function\") {\r\n      debug = function () { /* */ };\r\n    }\r\n  }\r\n  debug.apply(null, arguments);\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9kZWJ1Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsc0RBQU87QUFDN0I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mdXNpb24tYWkvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9kZWJ1Zy5qcz9hZGFjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWJ1ZztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICghZGVidWcpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8qIGVzbGludCBnbG9iYWwtcmVxdWlyZTogb2ZmICovXHJcbiAgICAgIGRlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpKFwiZm9sbG93LXJlZGlyZWN0c1wiKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyAvKiAqLyB9XHJcbiAgICBpZiAodHlwZW9mIGRlYnVnICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgZGVidWcgPSBmdW5jdGlvbiAoKSB7IC8qICovIH07XHJcbiAgICB9XHJcbiAgfVxyXG4gIGRlYnVnLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/follow-redirects/debug.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/follow-redirects/index.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var url = __webpack_require__(/*! url */ \"url\");\r\nvar URL = url.URL;\r\nvar http = __webpack_require__(/*! http */ \"http\");\r\nvar https = __webpack_require__(/*! https */ \"https\");\r\nvar Writable = (__webpack_require__(/*! stream */ \"stream\").Writable);\r\nvar assert = __webpack_require__(/*! assert */ \"assert\");\r\nvar debug = __webpack_require__(/*! ./debug */ \"(ssr)/./node_modules/follow-redirects/debug.js\");\r\n\r\n// Whether to use the native URL object or the legacy url module\r\nvar useNativeURL = false;\r\ntry {\r\n  assert(new URL());\r\n}\r\ncatch (error) {\r\n  useNativeURL = error.code === \"ERR_INVALID_URL\";\r\n}\r\n\r\n// URL fields to preserve in copy operations\r\nvar preservedUrlFields = [\r\n  \"auth\",\r\n  \"host\",\r\n  \"hostname\",\r\n  \"href\",\r\n  \"path\",\r\n  \"pathname\",\r\n  \"port\",\r\n  \"protocol\",\r\n  \"query\",\r\n  \"search\",\r\n  \"hash\",\r\n];\r\n\r\n// Create handlers that pass events from native requests\r\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\r\nvar eventHandlers = Object.create(null);\r\nevents.forEach(function (event) {\r\n  eventHandlers[event] = function (arg1, arg2, arg3) {\r\n    this._redirectable.emit(event, arg1, arg2, arg3);\r\n  };\r\n});\r\n\r\n// Error types with codes\r\nvar InvalidUrlError = createErrorType(\r\n  \"ERR_INVALID_URL\",\r\n  \"Invalid URL\",\r\n  TypeError\r\n);\r\nvar RedirectionError = createErrorType(\r\n  \"ERR_FR_REDIRECTION_FAILURE\",\r\n  \"Redirected request failed\"\r\n);\r\nvar TooManyRedirectsError = createErrorType(\r\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\r\n  \"Maximum number of redirects exceeded\",\r\n  RedirectionError\r\n);\r\nvar MaxBodyLengthExceededError = createErrorType(\r\n  \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\",\r\n  \"Request body larger than maxBodyLength limit\"\r\n);\r\nvar WriteAfterEndError = createErrorType(\r\n  \"ERR_STREAM_WRITE_AFTER_END\",\r\n  \"write after end\"\r\n);\r\n\r\n// istanbul ignore next\r\nvar destroy = Writable.prototype.destroy || noop;\r\n\r\n// An HTTP(S) request that can be redirected\r\nfunction RedirectableRequest(options, responseCallback) {\r\n  // Initialize the request\r\n  Writable.call(this);\r\n  this._sanitizeOptions(options);\r\n  this._options = options;\r\n  this._ended = false;\r\n  this._ending = false;\r\n  this._redirectCount = 0;\r\n  this._redirects = [];\r\n  this._requestBodyLength = 0;\r\n  this._requestBodyBuffers = [];\r\n\r\n  // Attach a callback if passed\r\n  if (responseCallback) {\r\n    this.on(\"response\", responseCallback);\r\n  }\r\n\r\n  // React to responses of native requests\r\n  var self = this;\r\n  this._onNativeResponse = function (response) {\r\n    try {\r\n      self._processResponse(response);\r\n    }\r\n    catch (cause) {\r\n      self.emit(\"error\", cause instanceof RedirectionError ?\r\n        cause : new RedirectionError({ cause: cause }));\r\n    }\r\n  };\r\n\r\n  // Perform the first request\r\n  this._performRequest();\r\n}\r\nRedirectableRequest.prototype = Object.create(Writable.prototype);\r\n\r\nRedirectableRequest.prototype.abort = function () {\r\n  destroyRequest(this._currentRequest);\r\n  this._currentRequest.abort();\r\n  this.emit(\"abort\");\r\n};\r\n\r\nRedirectableRequest.prototype.destroy = function (error) {\r\n  destroyRequest(this._currentRequest, error);\r\n  destroy.call(this, error);\r\n  return this;\r\n};\r\n\r\n// Writes buffered data to the current native request\r\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\r\n  // Writing is not allowed if end has been called\r\n  if (this._ending) {\r\n    throw new WriteAfterEndError();\r\n  }\r\n\r\n  // Validate input and shift parameters if necessary\r\n  if (!isString(data) && !isBuffer(data)) {\r\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\r\n  }\r\n  if (isFunction(encoding)) {\r\n    callback = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  // Ignore empty buffers, since writing them doesn't invoke the callback\r\n  // https://github.com/nodejs/node/issues/22066\r\n  if (data.length === 0) {\r\n    if (callback) {\r\n      callback();\r\n    }\r\n    return;\r\n  }\r\n  // Only write when we don't exceed the maximum body length\r\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\r\n    this._requestBodyLength += data.length;\r\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\r\n    this._currentRequest.write(data, encoding, callback);\r\n  }\r\n  // Error when we exceed the maximum body length\r\n  else {\r\n    this.emit(\"error\", new MaxBodyLengthExceededError());\r\n    this.abort();\r\n  }\r\n};\r\n\r\n// Ends the current native request\r\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\r\n  // Shift parameters if necessary\r\n  if (isFunction(data)) {\r\n    callback = data;\r\n    data = encoding = null;\r\n  }\r\n  else if (isFunction(encoding)) {\r\n    callback = encoding;\r\n    encoding = null;\r\n  }\r\n\r\n  // Write data if needed and end\r\n  if (!data) {\r\n    this._ended = this._ending = true;\r\n    this._currentRequest.end(null, null, callback);\r\n  }\r\n  else {\r\n    var self = this;\r\n    var currentRequest = this._currentRequest;\r\n    this.write(data, encoding, function () {\r\n      self._ended = true;\r\n      currentRequest.end(null, null, callback);\r\n    });\r\n    this._ending = true;\r\n  }\r\n};\r\n\r\n// Sets a header value on the current native request\r\nRedirectableRequest.prototype.setHeader = function (name, value) {\r\n  this._options.headers[name] = value;\r\n  this._currentRequest.setHeader(name, value);\r\n};\r\n\r\n// Clears a header value on the current native request\r\nRedirectableRequest.prototype.removeHeader = function (name) {\r\n  delete this._options.headers[name];\r\n  this._currentRequest.removeHeader(name);\r\n};\r\n\r\n// Global timeout for all underlying requests\r\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\r\n  var self = this;\r\n\r\n  // Destroys the socket on timeout\r\n  function destroyOnTimeout(socket) {\r\n    socket.setTimeout(msecs);\r\n    socket.removeListener(\"timeout\", socket.destroy);\r\n    socket.addListener(\"timeout\", socket.destroy);\r\n  }\r\n\r\n  // Sets up a timer to trigger a timeout event\r\n  function startTimer(socket) {\r\n    if (self._timeout) {\r\n      clearTimeout(self._timeout);\r\n    }\r\n    self._timeout = setTimeout(function () {\r\n      self.emit(\"timeout\");\r\n      clearTimer();\r\n    }, msecs);\r\n    destroyOnTimeout(socket);\r\n  }\r\n\r\n  // Stops a timeout from triggering\r\n  function clearTimer() {\r\n    // Clear the timeout\r\n    if (self._timeout) {\r\n      clearTimeout(self._timeout);\r\n      self._timeout = null;\r\n    }\r\n\r\n    // Clean up all attached listeners\r\n    self.removeListener(\"abort\", clearTimer);\r\n    self.removeListener(\"error\", clearTimer);\r\n    self.removeListener(\"response\", clearTimer);\r\n    self.removeListener(\"close\", clearTimer);\r\n    if (callback) {\r\n      self.removeListener(\"timeout\", callback);\r\n    }\r\n    if (!self.socket) {\r\n      self._currentRequest.removeListener(\"socket\", startTimer);\r\n    }\r\n  }\r\n\r\n  // Attach callback if passed\r\n  if (callback) {\r\n    this.on(\"timeout\", callback);\r\n  }\r\n\r\n  // Start the timer if or when the socket is opened\r\n  if (this.socket) {\r\n    startTimer(this.socket);\r\n  }\r\n  else {\r\n    this._currentRequest.once(\"socket\", startTimer);\r\n  }\r\n\r\n  // Clean up on events\r\n  this.on(\"socket\", destroyOnTimeout);\r\n  this.on(\"abort\", clearTimer);\r\n  this.on(\"error\", clearTimer);\r\n  this.on(\"response\", clearTimer);\r\n  this.on(\"close\", clearTimer);\r\n\r\n  return this;\r\n};\r\n\r\n// Proxy all other public ClientRequest methods\r\n[\r\n  \"flushHeaders\", \"getHeader\",\r\n  \"setNoDelay\", \"setSocketKeepAlive\",\r\n].forEach(function (method) {\r\n  RedirectableRequest.prototype[method] = function (a, b) {\r\n    return this._currentRequest[method](a, b);\r\n  };\r\n});\r\n\r\n// Proxy all public ClientRequest properties\r\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\r\n  Object.defineProperty(RedirectableRequest.prototype, property, {\r\n    get: function () { return this._currentRequest[property]; },\r\n  });\r\n});\r\n\r\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\r\n  // Ensure headers are always present\r\n  if (!options.headers) {\r\n    options.headers = {};\r\n  }\r\n\r\n  // Since http.request treats host as an alias of hostname,\r\n  // but the url module interprets host as hostname plus port,\r\n  // eliminate the host property to avoid confusion.\r\n  if (options.host) {\r\n    // Use hostname if set, because it has precedence\r\n    if (!options.hostname) {\r\n      options.hostname = options.host;\r\n    }\r\n    delete options.host;\r\n  }\r\n\r\n  // Complete the URL object when necessary\r\n  if (!options.pathname && options.path) {\r\n    var searchPos = options.path.indexOf(\"?\");\r\n    if (searchPos < 0) {\r\n      options.pathname = options.path;\r\n    }\r\n    else {\r\n      options.pathname = options.path.substring(0, searchPos);\r\n      options.search = options.path.substring(searchPos);\r\n    }\r\n  }\r\n};\r\n\r\n\r\n// Executes the next native request (initial or redirect)\r\nRedirectableRequest.prototype._performRequest = function () {\r\n  // Load the native protocol\r\n  var protocol = this._options.protocol;\r\n  var nativeProtocol = this._options.nativeProtocols[protocol];\r\n  if (!nativeProtocol) {\r\n    throw new TypeError(\"Unsupported protocol \" + protocol);\r\n  }\r\n\r\n  // If specified, use the agent corresponding to the protocol\r\n  // (HTTP and HTTPS use different types of agents)\r\n  if (this._options.agents) {\r\n    var scheme = protocol.slice(0, -1);\r\n    this._options.agent = this._options.agents[scheme];\r\n  }\r\n\r\n  // Create the native request and set up its event handlers\r\n  var request = this._currentRequest =\r\n        nativeProtocol.request(this._options, this._onNativeResponse);\r\n  request._redirectable = this;\r\n  for (var event of events) {\r\n    request.on(event, eventHandlers[event]);\r\n  }\r\n\r\n  // RFC7230§5.3.1: When making a request directly to an origin server, […]\r\n  // a client MUST send only the absolute path […] as the request-target.\r\n  this._currentUrl = /^\\//.test(this._options.path) ?\r\n    url.format(this._options) :\r\n    // When making a request to a proxy, […]\r\n    // a client MUST send the target URI in absolute-form […].\r\n    this._options.path;\r\n\r\n  // End a redirected request\r\n  // (The first request must be ended explicitly with RedirectableRequest#end)\r\n  if (this._isRedirect) {\r\n    // Write the request entity and end\r\n    var i = 0;\r\n    var self = this;\r\n    var buffers = this._requestBodyBuffers;\r\n    (function writeNext(error) {\r\n      // Only write if this request has not been redirected yet\r\n      /* istanbul ignore else */\r\n      if (request === self._currentRequest) {\r\n        // Report any write errors\r\n        /* istanbul ignore if */\r\n        if (error) {\r\n          self.emit(\"error\", error);\r\n        }\r\n        // Write the next buffer if there are still left\r\n        else if (i < buffers.length) {\r\n          var buffer = buffers[i++];\r\n          /* istanbul ignore else */\r\n          if (!request.finished) {\r\n            request.write(buffer.data, buffer.encoding, writeNext);\r\n          }\r\n        }\r\n        // End the request if `end` has been called on us\r\n        else if (self._ended) {\r\n          request.end();\r\n        }\r\n      }\r\n    }());\r\n  }\r\n};\r\n\r\n// Processes a response from the current native request\r\nRedirectableRequest.prototype._processResponse = function (response) {\r\n  // Store the redirected response\r\n  var statusCode = response.statusCode;\r\n  if (this._options.trackRedirects) {\r\n    this._redirects.push({\r\n      url: this._currentUrl,\r\n      headers: response.headers,\r\n      statusCode: statusCode,\r\n    });\r\n  }\r\n\r\n  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\r\n  // that further action needs to be taken by the user agent in order to\r\n  // fulfill the request. If a Location header field is provided,\r\n  // the user agent MAY automatically redirect its request to the URI\r\n  // referenced by the Location field value,\r\n  // even if the specific status code is not understood.\r\n\r\n  // If the response is not a redirect; return it as-is\r\n  var location = response.headers.location;\r\n  if (!location || this._options.followRedirects === false ||\r\n      statusCode < 300 || statusCode >= 400) {\r\n    response.responseUrl = this._currentUrl;\r\n    response.redirects = this._redirects;\r\n    this.emit(\"response\", response);\r\n\r\n    // Clean up\r\n    this._requestBodyBuffers = [];\r\n    return;\r\n  }\r\n\r\n  // The response is a redirect, so abort the current request\r\n  destroyRequest(this._currentRequest);\r\n  // Discard the remainder of the response to avoid waiting for data\r\n  response.destroy();\r\n\r\n  // RFC7231§6.4: A client SHOULD detect and intervene\r\n  // in cyclical redirections (i.e., \"infinite\" redirection loops).\r\n  if (++this._redirectCount > this._options.maxRedirects) {\r\n    throw new TooManyRedirectsError();\r\n  }\r\n\r\n  // Store the request headers if applicable\r\n  var requestHeaders;\r\n  var beforeRedirect = this._options.beforeRedirect;\r\n  if (beforeRedirect) {\r\n    requestHeaders = Object.assign({\r\n      // The Host header was set by nativeProtocol.request\r\n      Host: response.req.getHeader(\"host\"),\r\n    }, this._options.headers);\r\n  }\r\n\r\n  // RFC7231§6.4: Automatic redirection needs to done with\r\n  // care for methods not known to be safe, […]\r\n  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change\r\n  // the request method from POST to GET for the subsequent request.\r\n  var method = this._options.method;\r\n  if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\r\n      // RFC7231§6.4.4: The 303 (See Other) status code indicates that\r\n      // the server is redirecting the user agent to a different resource […]\r\n      // A user agent can perform a retrieval request targeting that URI\r\n      // (a GET or HEAD request if using HTTP) […]\r\n      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\r\n    this._options.method = \"GET\";\r\n    // Drop a possible entity and headers related to it\r\n    this._requestBodyBuffers = [];\r\n    removeMatchingHeaders(/^content-/i, this._options.headers);\r\n  }\r\n\r\n  // Drop the Host header, as the redirect might lead to a different host\r\n  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\r\n\r\n  // If the redirect is relative, carry over the host of the last request\r\n  var currentUrlParts = parseUrl(this._currentUrl);\r\n  var currentHost = currentHostHeader || currentUrlParts.host;\r\n  var currentUrl = /^\\w+:/.test(location) ? this._currentUrl :\r\n    url.format(Object.assign(currentUrlParts, { host: currentHost }));\r\n\r\n  // Create the redirected request\r\n  var redirectUrl = resolveUrl(location, currentUrl);\r\n  debug(\"redirecting to\", redirectUrl.href);\r\n  this._isRedirect = true;\r\n  spreadUrlObject(redirectUrl, this._options);\r\n\r\n  // Drop confidential headers when redirecting to a less secure protocol\r\n  // or to a different domain that is not a superdomain\r\n  if (redirectUrl.protocol !== currentUrlParts.protocol &&\r\n     redirectUrl.protocol !== \"https:\" ||\r\n     redirectUrl.host !== currentHost &&\r\n     !isSubdomain(redirectUrl.host, currentHost)) {\r\n    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);\r\n  }\r\n\r\n  // Evaluate the beforeRedirect callback\r\n  if (isFunction(beforeRedirect)) {\r\n    var responseDetails = {\r\n      headers: response.headers,\r\n      statusCode: statusCode,\r\n    };\r\n    var requestDetails = {\r\n      url: currentUrl,\r\n      method: method,\r\n      headers: requestHeaders,\r\n    };\r\n    beforeRedirect(this._options, responseDetails, requestDetails);\r\n    this._sanitizeOptions(this._options);\r\n  }\r\n\r\n  // Perform the redirected request\r\n  this._performRequest();\r\n};\r\n\r\n// Wraps the key/value object of protocols with redirect functionality\r\nfunction wrap(protocols) {\r\n  // Default settings\r\n  var exports = {\r\n    maxRedirects: 21,\r\n    maxBodyLength: 10 * 1024 * 1024,\r\n  };\r\n\r\n  // Wrap each protocol\r\n  var nativeProtocols = {};\r\n  Object.keys(protocols).forEach(function (scheme) {\r\n    var protocol = scheme + \":\";\r\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\r\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\r\n\r\n    // Executes a request, following redirects\r\n    function request(input, options, callback) {\r\n      // Parse parameters, ensuring that input is an object\r\n      if (isURL(input)) {\r\n        input = spreadUrlObject(input);\r\n      }\r\n      else if (isString(input)) {\r\n        input = spreadUrlObject(parseUrl(input));\r\n      }\r\n      else {\r\n        callback = options;\r\n        options = validateUrl(input);\r\n        input = { protocol: protocol };\r\n      }\r\n      if (isFunction(options)) {\r\n        callback = options;\r\n        options = null;\r\n      }\r\n\r\n      // Set defaults\r\n      options = Object.assign({\r\n        maxRedirects: exports.maxRedirects,\r\n        maxBodyLength: exports.maxBodyLength,\r\n      }, input, options);\r\n      options.nativeProtocols = nativeProtocols;\r\n      if (!isString(options.host) && !isString(options.hostname)) {\r\n        options.hostname = \"::1\";\r\n      }\r\n\r\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\r\n      debug(\"options\", options);\r\n      return new RedirectableRequest(options, callback);\r\n    }\r\n\r\n    // Executes a GET request, following redirects\r\n    function get(input, options, callback) {\r\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\r\n      wrappedRequest.end();\r\n      return wrappedRequest;\r\n    }\r\n\r\n    // Expose the properties on the wrapped protocol\r\n    Object.defineProperties(wrappedProtocol, {\r\n      request: { value: request, configurable: true, enumerable: true, writable: true },\r\n      get: { value: get, configurable: true, enumerable: true, writable: true },\r\n    });\r\n  });\r\n  return exports;\r\n}\r\n\r\nfunction noop() { /* empty */ }\r\n\r\nfunction parseUrl(input) {\r\n  var parsed;\r\n  /* istanbul ignore else */\r\n  if (useNativeURL) {\r\n    parsed = new URL(input);\r\n  }\r\n  else {\r\n    // Ensure the URL is valid and absolute\r\n    parsed = validateUrl(url.parse(input));\r\n    if (!isString(parsed.protocol)) {\r\n      throw new InvalidUrlError({ input });\r\n    }\r\n  }\r\n  return parsed;\r\n}\r\n\r\nfunction resolveUrl(relative, base) {\r\n  /* istanbul ignore next */\r\n  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));\r\n}\r\n\r\nfunction validateUrl(input) {\r\n  if (/^\\[/.test(input.hostname) && !/^\\[[:0-9a-f]+\\]$/i.test(input.hostname)) {\r\n    throw new InvalidUrlError({ input: input.href || input });\r\n  }\r\n  if (/^\\[/.test(input.host) && !/^\\[[:0-9a-f]+\\](:\\d+)?$/i.test(input.host)) {\r\n    throw new InvalidUrlError({ input: input.href || input });\r\n  }\r\n  return input;\r\n}\r\n\r\nfunction spreadUrlObject(urlObject, target) {\r\n  var spread = target || {};\r\n  for (var key of preservedUrlFields) {\r\n    spread[key] = urlObject[key];\r\n  }\r\n\r\n  // Fix IPv6 hostname\r\n  if (spread.hostname.startsWith(\"[\")) {\r\n    spread.hostname = spread.hostname.slice(1, -1);\r\n  }\r\n  // Ensure port is a number\r\n  if (spread.port !== \"\") {\r\n    spread.port = Number(spread.port);\r\n  }\r\n  // Concatenate path\r\n  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;\r\n\r\n  return spread;\r\n}\r\n\r\nfunction removeMatchingHeaders(regex, headers) {\r\n  var lastValue;\r\n  for (var header in headers) {\r\n    if (regex.test(header)) {\r\n      lastValue = headers[header];\r\n      delete headers[header];\r\n    }\r\n  }\r\n  return (lastValue === null || typeof lastValue === \"undefined\") ?\r\n    undefined : String(lastValue).trim();\r\n}\r\n\r\nfunction createErrorType(code, message, baseClass) {\r\n  // Create constructor\r\n  function CustomError(properties) {\r\n    Error.captureStackTrace(this, this.constructor);\r\n    Object.assign(this, properties || {});\r\n    this.code = code;\r\n    this.message = this.cause ? message + \": \" + this.cause.message : message;\r\n  }\r\n\r\n  // Attach constructor and set default properties\r\n  CustomError.prototype = new (baseClass || Error)();\r\n  Object.defineProperties(CustomError.prototype, {\r\n    constructor: {\r\n      value: CustomError,\r\n      enumerable: false,\r\n    },\r\n    name: {\r\n      value: \"Error [\" + code + \"]\",\r\n      enumerable: false,\r\n    },\r\n  });\r\n  return CustomError;\r\n}\r\n\r\nfunction destroyRequest(request, error) {\r\n  for (var event of events) {\r\n    request.removeListener(event, eventHandlers[event]);\r\n  }\r\n  request.on(\"error\", noop);\r\n  request.destroy(error);\r\n}\r\n\r\nfunction isSubdomain(subdomain, domain) {\r\n  assert(isString(subdomain) && isString(domain));\r\n  var dot = subdomain.length - domain.length - 1;\r\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\r\n}\r\n\r\nfunction isString(value) {\r\n  return typeof value === \"string\" || value instanceof String;\r\n}\r\n\r\nfunction isFunction(value) {\r\n  return typeof value === \"function\";\r\n}\r\n\r\nfunction isBuffer(value) {\r\n  return typeof value === \"object\" && (\"length\" in value);\r\n}\r\n\r\nfunction isURL(value) {\r\n  return URL && value instanceof URL;\r\n}\r\n\r\n// Exports\r\nmodule.exports = wrap({ http: http, https: https });\r\nmodule.exports.wrap = wrap;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9sbG93LXJlZGlyZWN0cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsZ0JBQUs7QUFDdkI7QUFDQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLG9CQUFPO0FBQzNCLGVBQWUsc0RBQTBCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixZQUFZLG1CQUFPLENBQUMsK0RBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdDQUFnQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0NBQXdDO0FBQy9ELEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQW1CO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0VBQXNFO0FBQ3ZGLGFBQWEsa0VBQWtFO0FBQy9FLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xELG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Z1c2lvbi1haS8uL25vZGVfbW9kdWxlcy9mb2xsb3ctcmVkaXJlY3RzL2luZGV4LmpzPzVkMjQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XHJcbnZhciBVUkwgPSB1cmwuVVJMO1xyXG52YXIgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xyXG52YXIgaHR0cHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XHJcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoXCJzdHJlYW1cIikuV3JpdGFibGU7XHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xyXG52YXIgZGVidWcgPSByZXF1aXJlKFwiLi9kZWJ1Z1wiKTtcclxuXHJcbi8vIFdoZXRoZXIgdG8gdXNlIHRoZSBuYXRpdmUgVVJMIG9iamVjdCBvciB0aGUgbGVnYWN5IHVybCBtb2R1bGVcclxudmFyIHVzZU5hdGl2ZVVSTCA9IGZhbHNlO1xyXG50cnkge1xyXG4gIGFzc2VydChuZXcgVVJMKCkpO1xyXG59XHJcbmNhdGNoIChlcnJvcikge1xyXG4gIHVzZU5hdGl2ZVVSTCA9IGVycm9yLmNvZGUgPT09IFwiRVJSX0lOVkFMSURfVVJMXCI7XHJcbn1cclxuXHJcbi8vIFVSTCBmaWVsZHMgdG8gcHJlc2VydmUgaW4gY29weSBvcGVyYXRpb25zXHJcbnZhciBwcmVzZXJ2ZWRVcmxGaWVsZHMgPSBbXHJcbiAgXCJhdXRoXCIsXHJcbiAgXCJob3N0XCIsXHJcbiAgXCJob3N0bmFtZVwiLFxyXG4gIFwiaHJlZlwiLFxyXG4gIFwicGF0aFwiLFxyXG4gIFwicGF0aG5hbWVcIixcclxuICBcInBvcnRcIixcclxuICBcInByb3RvY29sXCIsXHJcbiAgXCJxdWVyeVwiLFxyXG4gIFwic2VhcmNoXCIsXHJcbiAgXCJoYXNoXCIsXHJcbl07XHJcblxyXG4vLyBDcmVhdGUgaGFuZGxlcnMgdGhhdCBwYXNzIGV2ZW50cyBmcm9tIG5hdGl2ZSByZXF1ZXN0c1xyXG52YXIgZXZlbnRzID0gW1wiYWJvcnRcIiwgXCJhYm9ydGVkXCIsIFwiY29ubmVjdFwiLCBcImVycm9yXCIsIFwic29ja2V0XCIsIFwidGltZW91dFwiXTtcclxudmFyIGV2ZW50SGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcclxuICBldmVudEhhbmRsZXJzW2V2ZW50XSA9IGZ1bmN0aW9uIChhcmcxLCBhcmcyLCBhcmczKSB7XHJcbiAgICB0aGlzLl9yZWRpcmVjdGFibGUuZW1pdChldmVudCwgYXJnMSwgYXJnMiwgYXJnMyk7XHJcbiAgfTtcclxufSk7XHJcblxyXG4vLyBFcnJvciB0eXBlcyB3aXRoIGNvZGVzXHJcbnZhciBJbnZhbGlkVXJsRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXHJcbiAgXCJFUlJfSU5WQUxJRF9VUkxcIixcclxuICBcIkludmFsaWQgVVJMXCIsXHJcbiAgVHlwZUVycm9yXHJcbik7XHJcbnZhciBSZWRpcmVjdGlvbkVycm9yID0gY3JlYXRlRXJyb3JUeXBlKFxyXG4gIFwiRVJSX0ZSX1JFRElSRUNUSU9OX0ZBSUxVUkVcIixcclxuICBcIlJlZGlyZWN0ZWQgcmVxdWVzdCBmYWlsZWRcIlxyXG4pO1xyXG52YXIgVG9vTWFueVJlZGlyZWN0c0Vycm9yID0gY3JlYXRlRXJyb3JUeXBlKFxyXG4gIFwiRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUU1wiLFxyXG4gIFwiTWF4aW11bSBudW1iZXIgb2YgcmVkaXJlY3RzIGV4Y2VlZGVkXCIsXHJcbiAgUmVkaXJlY3Rpb25FcnJvclxyXG4pO1xyXG52YXIgTWF4Qm9keUxlbmd0aEV4Y2VlZGVkRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXHJcbiAgXCJFUlJfRlJfTUFYX0JPRFlfTEVOR1RIX0VYQ0VFREVEXCIsXHJcbiAgXCJSZXF1ZXN0IGJvZHkgbGFyZ2VyIHRoYW4gbWF4Qm9keUxlbmd0aCBsaW1pdFwiXHJcbik7XHJcbnZhciBXcml0ZUFmdGVyRW5kRXJyb3IgPSBjcmVhdGVFcnJvclR5cGUoXHJcbiAgXCJFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORFwiLFxyXG4gIFwid3JpdGUgYWZ0ZXIgZW5kXCJcclxuKTtcclxuXHJcbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XHJcbnZhciBkZXN0cm95ID0gV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgfHwgbm9vcDtcclxuXHJcbi8vIEFuIEhUVFAoUykgcmVxdWVzdCB0aGF0IGNhbiBiZSByZWRpcmVjdGVkXHJcbmZ1bmN0aW9uIFJlZGlyZWN0YWJsZVJlcXVlc3Qob3B0aW9ucywgcmVzcG9uc2VDYWxsYmFjaykge1xyXG4gIC8vIEluaXRpYWxpemUgdGhlIHJlcXVlc3RcclxuICBXcml0YWJsZS5jYWxsKHRoaXMpO1xyXG4gIHRoaXMuX3Nhbml0aXplT3B0aW9ucyhvcHRpb25zKTtcclxuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcclxuICB0aGlzLl9lbmRlZCA9IGZhbHNlO1xyXG4gIHRoaXMuX2VuZGluZyA9IGZhbHNlO1xyXG4gIHRoaXMuX3JlZGlyZWN0Q291bnQgPSAwO1xyXG4gIHRoaXMuX3JlZGlyZWN0cyA9IFtdO1xyXG4gIHRoaXMuX3JlcXVlc3RCb2R5TGVuZ3RoID0gMDtcclxuICB0aGlzLl9yZXF1ZXN0Qm9keUJ1ZmZlcnMgPSBbXTtcclxuXHJcbiAgLy8gQXR0YWNoIGEgY2FsbGJhY2sgaWYgcGFzc2VkXHJcbiAgaWYgKHJlc3BvbnNlQ2FsbGJhY2spIHtcclxuICAgIHRoaXMub24oXCJyZXNwb25zZVwiLCByZXNwb25zZUNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIC8vIFJlYWN0IHRvIHJlc3BvbnNlcyBvZiBuYXRpdmUgcmVxdWVzdHNcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdGhpcy5fb25OYXRpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgc2VsZi5fcHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChjYXVzZSkge1xyXG4gICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBjYXVzZSBpbnN0YW5jZW9mIFJlZGlyZWN0aW9uRXJyb3IgP1xyXG4gICAgICAgIGNhdXNlIDogbmV3IFJlZGlyZWN0aW9uRXJyb3IoeyBjYXVzZTogY2F1c2UgfSkpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIFBlcmZvcm0gdGhlIGZpcnN0IHJlcXVlc3RcclxuICB0aGlzLl9wZXJmb3JtUmVxdWVzdCgpO1xyXG59XHJcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZS5wcm90b3R5cGUpO1xyXG5cclxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgZGVzdHJveVJlcXVlc3QodGhpcy5fY3VycmVudFJlcXVlc3QpO1xyXG4gIHRoaXMuX2N1cnJlbnRSZXF1ZXN0LmFib3J0KCk7XHJcbiAgdGhpcy5lbWl0KFwiYWJvcnRcIik7XHJcbn07XHJcblxyXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgZGVzdHJveVJlcXVlc3QodGhpcy5fY3VycmVudFJlcXVlc3QsIGVycm9yKTtcclxuICBkZXN0cm95LmNhbGwodGhpcywgZXJyb3IpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8gV3JpdGVzIGJ1ZmZlcmVkIGRhdGEgdG8gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcclxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XHJcbiAgLy8gV3JpdGluZyBpcyBub3QgYWxsb3dlZCBpZiBlbmQgaGFzIGJlZW4gY2FsbGVkXHJcbiAgaWYgKHRoaXMuX2VuZGluZykge1xyXG4gICAgdGhyb3cgbmV3IFdyaXRlQWZ0ZXJFbmRFcnJvcigpO1xyXG4gIH1cclxuXHJcbiAgLy8gVmFsaWRhdGUgaW5wdXQgYW5kIHNoaWZ0IHBhcmFtZXRlcnMgaWYgbmVjZXNzYXJ5XHJcbiAgaWYgKCFpc1N0cmluZyhkYXRhKSAmJiAhaXNCdWZmZXIoZGF0YSkpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJkYXRhIHNob3VsZCBiZSBhIHN0cmluZywgQnVmZmVyIG9yIFVpbnQ4QXJyYXlcIik7XHJcbiAgfVxyXG4gIGlmIChpc0Z1bmN0aW9uKGVuY29kaW5nKSkge1xyXG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZztcclxuICAgIGVuY29kaW5nID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIElnbm9yZSBlbXB0eSBidWZmZXJzLCBzaW5jZSB3cml0aW5nIHRoZW0gZG9lc24ndCBpbnZva2UgdGhlIGNhbGxiYWNrXHJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8yMjA2NlxyXG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8vIE9ubHkgd3JpdGUgd2hlbiB3ZSBkb24ndCBleGNlZWQgdGhlIG1heGltdW0gYm9keSBsZW5ndGhcclxuICBpZiAodGhpcy5fcmVxdWVzdEJvZHlMZW5ndGggKyBkYXRhLmxlbmd0aCA8PSB0aGlzLl9vcHRpb25zLm1heEJvZHlMZW5ndGgpIHtcclxuICAgIHRoaXMuX3JlcXVlc3RCb2R5TGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xyXG4gICAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzLnB1c2goeyBkYXRhOiBkYXRhLCBlbmNvZGluZzogZW5jb2RpbmcgfSk7XHJcbiAgICB0aGlzLl9jdXJyZW50UmVxdWVzdC53cml0ZShkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spO1xyXG4gIH1cclxuICAvLyBFcnJvciB3aGVuIHdlIGV4Y2VlZCB0aGUgbWF4aW11bSBib2R5IGxlbmd0aFxyXG4gIGVsc2Uge1xyXG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbmV3IE1heEJvZHlMZW5ndGhFeGNlZWRlZEVycm9yKCkpO1xyXG4gICAgdGhpcy5hYm9ydCgpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEVuZHMgdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcclxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xyXG4gIC8vIFNoaWZ0IHBhcmFtZXRlcnMgaWYgbmVjZXNzYXJ5XHJcbiAgaWYgKGlzRnVuY3Rpb24oZGF0YSkpIHtcclxuICAgIGNhbGxiYWNrID0gZGF0YTtcclxuICAgIGRhdGEgPSBlbmNvZGluZyA9IG51bGw7XHJcbiAgfVxyXG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XHJcbiAgICBjYWxsYmFjayA9IGVuY29kaW5nO1xyXG4gICAgZW5jb2RpbmcgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gV3JpdGUgZGF0YSBpZiBuZWVkZWQgYW5kIGVuZFxyXG4gIGlmICghZGF0YSkge1xyXG4gICAgdGhpcy5fZW5kZWQgPSB0aGlzLl9lbmRpbmcgPSB0cnVlO1xyXG4gICAgdGhpcy5fY3VycmVudFJlcXVlc3QuZW5kKG51bGwsIG51bGwsIGNhbGxiYWNrKTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgY3VycmVudFJlcXVlc3QgPSB0aGlzLl9jdXJyZW50UmVxdWVzdDtcclxuICAgIHRoaXMud3JpdGUoZGF0YSwgZW5jb2RpbmcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgc2VsZi5fZW5kZWQgPSB0cnVlO1xyXG4gICAgICBjdXJyZW50UmVxdWVzdC5lbmQobnVsbCwgbnVsbCwgY2FsbGJhY2spO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLl9lbmRpbmcgPSB0cnVlO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFNldHMgYSBoZWFkZXIgdmFsdWUgb24gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcclxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XHJcbiAgdGhpcy5fb3B0aW9ucy5oZWFkZXJzW25hbWVdID0gdmFsdWU7XHJcbiAgdGhpcy5fY3VycmVudFJlcXVlc3Quc2V0SGVhZGVyKG5hbWUsIHZhbHVlKTtcclxufTtcclxuXHJcbi8vIENsZWFycyBhIGhlYWRlciB2YWx1ZSBvbiB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxyXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIGRlbGV0ZSB0aGlzLl9vcHRpb25zLmhlYWRlcnNbbmFtZV07XHJcbiAgdGhpcy5fY3VycmVudFJlcXVlc3QucmVtb3ZlSGVhZGVyKG5hbWUpO1xyXG59O1xyXG5cclxuLy8gR2xvYmFsIHRpbWVvdXQgZm9yIGFsbCB1bmRlcmx5aW5nIHJlcXVlc3RzXHJcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAobXNlY3MsIGNhbGxiYWNrKSB7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAvLyBEZXN0cm95cyB0aGUgc29ja2V0IG9uIHRpbWVvdXRcclxuICBmdW5jdGlvbiBkZXN0cm95T25UaW1lb3V0KHNvY2tldCkge1xyXG4gICAgc29ja2V0LnNldFRpbWVvdXQobXNlY3MpO1xyXG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKFwidGltZW91dFwiLCBzb2NrZXQuZGVzdHJveSk7XHJcbiAgICBzb2NrZXQuYWRkTGlzdGVuZXIoXCJ0aW1lb3V0XCIsIHNvY2tldC5kZXN0cm95KTtcclxuICB9XHJcblxyXG4gIC8vIFNldHMgdXAgYSB0aW1lciB0byB0cmlnZ2VyIGEgdGltZW91dCBldmVudFxyXG4gIGZ1bmN0aW9uIHN0YXJ0VGltZXIoc29ja2V0KSB7XHJcbiAgICBpZiAoc2VsZi5fdGltZW91dCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5fdGltZW91dCk7XHJcbiAgICB9XHJcbiAgICBzZWxmLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHNlbGYuZW1pdChcInRpbWVvdXRcIik7XHJcbiAgICAgIGNsZWFyVGltZXIoKTtcclxuICAgIH0sIG1zZWNzKTtcclxuICAgIGRlc3Ryb3lPblRpbWVvdXQoc29ja2V0KTtcclxuICB9XHJcblxyXG4gIC8vIFN0b3BzIGEgdGltZW91dCBmcm9tIHRyaWdnZXJpbmdcclxuICBmdW5jdGlvbiBjbGVhclRpbWVyKCkge1xyXG4gICAgLy8gQ2xlYXIgdGhlIHRpbWVvdXRcclxuICAgIGlmIChzZWxmLl90aW1lb3V0KSB7XHJcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl90aW1lb3V0KTtcclxuICAgICAgc2VsZi5fdGltZW91dCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2xlYW4gdXAgYWxsIGF0dGFjaGVkIGxpc3RlbmVyc1xyXG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcImFib3J0XCIsIGNsZWFyVGltZXIpO1xyXG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIGNsZWFyVGltZXIpO1xyXG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcInJlc3BvbnNlXCIsIGNsZWFyVGltZXIpO1xyXG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIGNsZWFyVGltZXIpO1xyXG4gICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoXCJ0aW1lb3V0XCIsIGNhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGlmICghc2VsZi5zb2NrZXQpIHtcclxuICAgICAgc2VsZi5fY3VycmVudFJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoXCJzb2NrZXRcIiwgc3RhcnRUaW1lcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBdHRhY2ggY2FsbGJhY2sgaWYgcGFzc2VkXHJcbiAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLm9uKFwidGltZW91dFwiLCBjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICAvLyBTdGFydCB0aGUgdGltZXIgaWYgb3Igd2hlbiB0aGUgc29ja2V0IGlzIG9wZW5lZFxyXG4gIGlmICh0aGlzLnNvY2tldCkge1xyXG4gICAgc3RhcnRUaW1lcih0aGlzLnNvY2tldCk7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgdGhpcy5fY3VycmVudFJlcXVlc3Qub25jZShcInNvY2tldFwiLCBzdGFydFRpbWVyKTtcclxuICB9XHJcblxyXG4gIC8vIENsZWFuIHVwIG9uIGV2ZW50c1xyXG4gIHRoaXMub24oXCJzb2NrZXRcIiwgZGVzdHJveU9uVGltZW91dCk7XHJcbiAgdGhpcy5vbihcImFib3J0XCIsIGNsZWFyVGltZXIpO1xyXG4gIHRoaXMub24oXCJlcnJvclwiLCBjbGVhclRpbWVyKTtcclxuICB0aGlzLm9uKFwicmVzcG9uc2VcIiwgY2xlYXJUaW1lcik7XHJcbiAgdGhpcy5vbihcImNsb3NlXCIsIGNsZWFyVGltZXIpO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8vIFByb3h5IGFsbCBvdGhlciBwdWJsaWMgQ2xpZW50UmVxdWVzdCBtZXRob2RzXHJcbltcclxuICBcImZsdXNoSGVhZGVyc1wiLCBcImdldEhlYWRlclwiLFxyXG4gIFwic2V0Tm9EZWxheVwiLCBcInNldFNvY2tldEtlZXBBbGl2ZVwiLFxyXG5dLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gIFJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRSZXF1ZXN0W21ldGhvZF0oYSwgYik7XHJcbiAgfTtcclxufSk7XHJcblxyXG4vLyBQcm94eSBhbGwgcHVibGljIENsaWVudFJlcXVlc3QgcHJvcGVydGllc1xyXG5bXCJhYm9ydGVkXCIsIFwiY29ubmVjdGlvblwiLCBcInNvY2tldFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZSwgcHJvcGVydHksIHtcclxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY3VycmVudFJlcXVlc3RbcHJvcGVydHldOyB9LFxyXG4gIH0pO1xyXG59KTtcclxuXHJcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLl9zYW5pdGl6ZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGFyZSBhbHdheXMgcHJlc2VudFxyXG4gIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XHJcbiAgICBvcHRpb25zLmhlYWRlcnMgPSB7fTtcclxuICB9XHJcblxyXG4gIC8vIFNpbmNlIGh0dHAucmVxdWVzdCB0cmVhdHMgaG9zdCBhcyBhbiBhbGlhcyBvZiBob3N0bmFtZSxcclxuICAvLyBidXQgdGhlIHVybCBtb2R1bGUgaW50ZXJwcmV0cyBob3N0IGFzIGhvc3RuYW1lIHBsdXMgcG9ydCxcclxuICAvLyBlbGltaW5hdGUgdGhlIGhvc3QgcHJvcGVydHkgdG8gYXZvaWQgY29uZnVzaW9uLlxyXG4gIGlmIChvcHRpb25zLmhvc3QpIHtcclxuICAgIC8vIFVzZSBob3N0bmFtZSBpZiBzZXQsIGJlY2F1c2UgaXQgaGFzIHByZWNlZGVuY2VcclxuICAgIGlmICghb3B0aW9ucy5ob3N0bmFtZSkge1xyXG4gICAgICBvcHRpb25zLmhvc3RuYW1lID0gb3B0aW9ucy5ob3N0O1xyXG4gICAgfVxyXG4gICAgZGVsZXRlIG9wdGlvbnMuaG9zdDtcclxuICB9XHJcblxyXG4gIC8vIENvbXBsZXRlIHRoZSBVUkwgb2JqZWN0IHdoZW4gbmVjZXNzYXJ5XHJcbiAgaWYgKCFvcHRpb25zLnBhdGhuYW1lICYmIG9wdGlvbnMucGF0aCkge1xyXG4gICAgdmFyIHNlYXJjaFBvcyA9IG9wdGlvbnMucGF0aC5pbmRleE9mKFwiP1wiKTtcclxuICAgIGlmIChzZWFyY2hQb3MgPCAwKSB7XHJcbiAgICAgIG9wdGlvbnMucGF0aG5hbWUgPSBvcHRpb25zLnBhdGg7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgb3B0aW9ucy5wYXRobmFtZSA9IG9wdGlvbnMucGF0aC5zdWJzdHJpbmcoMCwgc2VhcmNoUG9zKTtcclxuICAgICAgb3B0aW9ucy5zZWFyY2ggPSBvcHRpb25zLnBhdGguc3Vic3RyaW5nKHNlYXJjaFBvcyk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8vIEV4ZWN1dGVzIHRoZSBuZXh0IG5hdGl2ZSByZXF1ZXN0IChpbml0aWFsIG9yIHJlZGlyZWN0KVxyXG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5fcGVyZm9ybVJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgLy8gTG9hZCB0aGUgbmF0aXZlIHByb3RvY29sXHJcbiAgdmFyIHByb3RvY29sID0gdGhpcy5fb3B0aW9ucy5wcm90b2NvbDtcclxuICB2YXIgbmF0aXZlUHJvdG9jb2wgPSB0aGlzLl9vcHRpb25zLm5hdGl2ZVByb3RvY29sc1twcm90b2NvbF07XHJcbiAgaWYgKCFuYXRpdmVQcm90b2NvbCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIHByb3RvY29sIFwiICsgcHJvdG9jb2wpO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgc3BlY2lmaWVkLCB1c2UgdGhlIGFnZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3RvY29sXHJcbiAgLy8gKEhUVFAgYW5kIEhUVFBTIHVzZSBkaWZmZXJlbnQgdHlwZXMgb2YgYWdlbnRzKVxyXG4gIGlmICh0aGlzLl9vcHRpb25zLmFnZW50cykge1xyXG4gICAgdmFyIHNjaGVtZSA9IHByb3RvY29sLnNsaWNlKDAsIC0xKTtcclxuICAgIHRoaXMuX29wdGlvbnMuYWdlbnQgPSB0aGlzLl9vcHRpb25zLmFnZW50c1tzY2hlbWVdO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIHRoZSBuYXRpdmUgcmVxdWVzdCBhbmQgc2V0IHVwIGl0cyBldmVudCBoYW5kbGVyc1xyXG4gIHZhciByZXF1ZXN0ID0gdGhpcy5fY3VycmVudFJlcXVlc3QgPVxyXG4gICAgICAgIG5hdGl2ZVByb3RvY29sLnJlcXVlc3QodGhpcy5fb3B0aW9ucywgdGhpcy5fb25OYXRpdmVSZXNwb25zZSk7XHJcbiAgcmVxdWVzdC5fcmVkaXJlY3RhYmxlID0gdGhpcztcclxuICBmb3IgKHZhciBldmVudCBvZiBldmVudHMpIHtcclxuICAgIHJlcXVlc3Qub24oZXZlbnQsIGV2ZW50SGFuZGxlcnNbZXZlbnRdKTtcclxuICB9XHJcblxyXG4gIC8vIFJGQzcyMzDCpzUuMy4xOiBXaGVuIG1ha2luZyBhIHJlcXVlc3QgZGlyZWN0bHkgdG8gYW4gb3JpZ2luIHNlcnZlciwgW+KApl1cclxuICAvLyBhIGNsaWVudCBNVVNUIHNlbmQgb25seSB0aGUgYWJzb2x1dGUgcGF0aCBb4oCmXSBhcyB0aGUgcmVxdWVzdC10YXJnZXQuXHJcbiAgdGhpcy5fY3VycmVudFVybCA9IC9eXFwvLy50ZXN0KHRoaXMuX29wdGlvbnMucGF0aCkgP1xyXG4gICAgdXJsLmZvcm1hdCh0aGlzLl9vcHRpb25zKSA6XHJcbiAgICAvLyBXaGVuIG1ha2luZyBhIHJlcXVlc3QgdG8gYSBwcm94eSwgW+KApl1cclxuICAgIC8vIGEgY2xpZW50IE1VU1Qgc2VuZCB0aGUgdGFyZ2V0IFVSSSBpbiBhYnNvbHV0ZS1mb3JtIFvigKZdLlxyXG4gICAgdGhpcy5fb3B0aW9ucy5wYXRoO1xyXG5cclxuICAvLyBFbmQgYSByZWRpcmVjdGVkIHJlcXVlc3RcclxuICAvLyAoVGhlIGZpcnN0IHJlcXVlc3QgbXVzdCBiZSBlbmRlZCBleHBsaWNpdGx5IHdpdGggUmVkaXJlY3RhYmxlUmVxdWVzdCNlbmQpXHJcbiAgaWYgKHRoaXMuX2lzUmVkaXJlY3QpIHtcclxuICAgIC8vIFdyaXRlIHRoZSByZXF1ZXN0IGVudGl0eSBhbmQgZW5kXHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgYnVmZmVycyA9IHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycztcclxuICAgIChmdW5jdGlvbiB3cml0ZU5leHQoZXJyb3IpIHtcclxuICAgICAgLy8gT25seSB3cml0ZSBpZiB0aGlzIHJlcXVlc3QgaGFzIG5vdCBiZWVuIHJlZGlyZWN0ZWQgeWV0XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgIGlmIChyZXF1ZXN0ID09PSBzZWxmLl9jdXJyZW50UmVxdWVzdCkge1xyXG4gICAgICAgIC8vIFJlcG9ydCBhbnkgd3JpdGUgZXJyb3JzXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdyaXRlIHRoZSBuZXh0IGJ1ZmZlciBpZiB0aGVyZSBhcmUgc3RpbGwgbGVmdFxyXG4gICAgICAgIGVsc2UgaWYgKGkgPCBidWZmZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbaSsrXTtcclxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgICBpZiAoIXJlcXVlc3QuZmluaXNoZWQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdC53cml0ZShidWZmZXIuZGF0YSwgYnVmZmVyLmVuY29kaW5nLCB3cml0ZU5leHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFbmQgdGhlIHJlcXVlc3QgaWYgYGVuZGAgaGFzIGJlZW4gY2FsbGVkIG9uIHVzXHJcbiAgICAgICAgZWxzZSBpZiAoc2VsZi5fZW5kZWQpIHtcclxuICAgICAgICAgIHJlcXVlc3QuZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KCkpO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFByb2Nlc3NlcyBhIHJlc3BvbnNlIGZyb20gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcclxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuX3Byb2Nlc3NSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xyXG4gIC8vIFN0b3JlIHRoZSByZWRpcmVjdGVkIHJlc3BvbnNlXHJcbiAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xyXG4gIGlmICh0aGlzLl9vcHRpb25zLnRyYWNrUmVkaXJlY3RzKSB7XHJcbiAgICB0aGlzLl9yZWRpcmVjdHMucHVzaCh7XHJcbiAgICAgIHVybDogdGhpcy5fY3VycmVudFVybCxcclxuICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcclxuICAgICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gUkZDNzIzMcKnNi40OiBUaGUgM3h4IChSZWRpcmVjdGlvbikgY2xhc3Mgb2Ygc3RhdHVzIGNvZGUgaW5kaWNhdGVzXHJcbiAgLy8gdGhhdCBmdXJ0aGVyIGFjdGlvbiBuZWVkcyB0byBiZSB0YWtlbiBieSB0aGUgdXNlciBhZ2VudCBpbiBvcmRlciB0b1xyXG4gIC8vIGZ1bGZpbGwgdGhlIHJlcXVlc3QuIElmIGEgTG9jYXRpb24gaGVhZGVyIGZpZWxkIGlzIHByb3ZpZGVkLFxyXG4gIC8vIHRoZSB1c2VyIGFnZW50IE1BWSBhdXRvbWF0aWNhbGx5IHJlZGlyZWN0IGl0cyByZXF1ZXN0IHRvIHRoZSBVUklcclxuICAvLyByZWZlcmVuY2VkIGJ5IHRoZSBMb2NhdGlvbiBmaWVsZCB2YWx1ZSxcclxuICAvLyBldmVuIGlmIHRoZSBzcGVjaWZpYyBzdGF0dXMgY29kZSBpcyBub3QgdW5kZXJzdG9vZC5cclxuXHJcbiAgLy8gSWYgdGhlIHJlc3BvbnNlIGlzIG5vdCBhIHJlZGlyZWN0OyByZXR1cm4gaXQgYXMtaXNcclxuICB2YXIgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uO1xyXG4gIGlmICghbG9jYXRpb24gfHwgdGhpcy5fb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHMgPT09IGZhbHNlIHx8XHJcbiAgICAgIHN0YXR1c0NvZGUgPCAzMDAgfHwgc3RhdHVzQ29kZSA+PSA0MDApIHtcclxuICAgIHJlc3BvbnNlLnJlc3BvbnNlVXJsID0gdGhpcy5fY3VycmVudFVybDtcclxuICAgIHJlc3BvbnNlLnJlZGlyZWN0cyA9IHRoaXMuX3JlZGlyZWN0cztcclxuICAgIHRoaXMuZW1pdChcInJlc3BvbnNlXCIsIHJlc3BvbnNlKTtcclxuXHJcbiAgICAvLyBDbGVhbiB1cFxyXG4gICAgdGhpcy5fcmVxdWVzdEJvZHlCdWZmZXJzID0gW107XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgcmVzcG9uc2UgaXMgYSByZWRpcmVjdCwgc28gYWJvcnQgdGhlIGN1cnJlbnQgcmVxdWVzdFxyXG4gIGRlc3Ryb3lSZXF1ZXN0KHRoaXMuX2N1cnJlbnRSZXF1ZXN0KTtcclxuICAvLyBEaXNjYXJkIHRoZSByZW1haW5kZXIgb2YgdGhlIHJlc3BvbnNlIHRvIGF2b2lkIHdhaXRpbmcgZm9yIGRhdGFcclxuICByZXNwb25zZS5kZXN0cm95KCk7XHJcblxyXG4gIC8vIFJGQzcyMzHCpzYuNDogQSBjbGllbnQgU0hPVUxEIGRldGVjdCBhbmQgaW50ZXJ2ZW5lXHJcbiAgLy8gaW4gY3ljbGljYWwgcmVkaXJlY3Rpb25zIChpLmUuLCBcImluZmluaXRlXCIgcmVkaXJlY3Rpb24gbG9vcHMpLlxyXG4gIGlmICgrK3RoaXMuX3JlZGlyZWN0Q291bnQgPiB0aGlzLl9vcHRpb25zLm1heFJlZGlyZWN0cykge1xyXG4gICAgdGhyb3cgbmV3IFRvb01hbnlSZWRpcmVjdHNFcnJvcigpO1xyXG4gIH1cclxuXHJcbiAgLy8gU3RvcmUgdGhlIHJlcXVlc3QgaGVhZGVycyBpZiBhcHBsaWNhYmxlXHJcbiAgdmFyIHJlcXVlc3RIZWFkZXJzO1xyXG4gIHZhciBiZWZvcmVSZWRpcmVjdCA9IHRoaXMuX29wdGlvbnMuYmVmb3JlUmVkaXJlY3Q7XHJcbiAgaWYgKGJlZm9yZVJlZGlyZWN0KSB7XHJcbiAgICByZXF1ZXN0SGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAvLyBUaGUgSG9zdCBoZWFkZXIgd2FzIHNldCBieSBuYXRpdmVQcm90b2NvbC5yZXF1ZXN0XHJcbiAgICAgIEhvc3Q6IHJlc3BvbnNlLnJlcS5nZXRIZWFkZXIoXCJob3N0XCIpLFxyXG4gICAgfSwgdGhpcy5fb3B0aW9ucy5oZWFkZXJzKTtcclxuICB9XHJcblxyXG4gIC8vIFJGQzcyMzHCpzYuNDogQXV0b21hdGljIHJlZGlyZWN0aW9uIG5lZWRzIHRvIGRvbmUgd2l0aFxyXG4gIC8vIGNhcmUgZm9yIG1ldGhvZHMgbm90IGtub3duIHRvIGJlIHNhZmUsIFvigKZdXHJcbiAgLy8gUkZDNzIzMcKnNi40LjLigJMzOiBGb3IgaGlzdG9yaWNhbCByZWFzb25zLCBhIHVzZXIgYWdlbnQgTUFZIGNoYW5nZVxyXG4gIC8vIHRoZSByZXF1ZXN0IG1ldGhvZCBmcm9tIFBPU1QgdG8gR0VUIGZvciB0aGUgc3Vic2VxdWVudCByZXF1ZXN0LlxyXG4gIHZhciBtZXRob2QgPSB0aGlzLl9vcHRpb25zLm1ldGhvZDtcclxuICBpZiAoKHN0YXR1c0NvZGUgPT09IDMwMSB8fCBzdGF0dXNDb2RlID09PSAzMDIpICYmIHRoaXMuX29wdGlvbnMubWV0aG9kID09PSBcIlBPU1RcIiB8fFxyXG4gICAgICAvLyBSRkM3MjMxwqc2LjQuNDogVGhlIDMwMyAoU2VlIE90aGVyKSBzdGF0dXMgY29kZSBpbmRpY2F0ZXMgdGhhdFxyXG4gICAgICAvLyB0aGUgc2VydmVyIGlzIHJlZGlyZWN0aW5nIHRoZSB1c2VyIGFnZW50IHRvIGEgZGlmZmVyZW50IHJlc291cmNlIFvigKZdXHJcbiAgICAgIC8vIEEgdXNlciBhZ2VudCBjYW4gcGVyZm9ybSBhIHJldHJpZXZhbCByZXF1ZXN0IHRhcmdldGluZyB0aGF0IFVSSVxyXG4gICAgICAvLyAoYSBHRVQgb3IgSEVBRCByZXF1ZXN0IGlmIHVzaW5nIEhUVFApIFvigKZdXHJcbiAgICAgIChzdGF0dXNDb2RlID09PSAzMDMpICYmICEvXig/OkdFVHxIRUFEKSQvLnRlc3QodGhpcy5fb3B0aW9ucy5tZXRob2QpKSB7XHJcbiAgICB0aGlzLl9vcHRpb25zLm1ldGhvZCA9IFwiR0VUXCI7XHJcbiAgICAvLyBEcm9wIGEgcG9zc2libGUgZW50aXR5IGFuZCBoZWFkZXJzIHJlbGF0ZWQgdG8gaXRcclxuICAgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdO1xyXG4gICAgcmVtb3ZlTWF0Y2hpbmdIZWFkZXJzKC9eY29udGVudC0vaSwgdGhpcy5fb3B0aW9ucy5oZWFkZXJzKTtcclxuICB9XHJcblxyXG4gIC8vIERyb3AgdGhlIEhvc3QgaGVhZGVyLCBhcyB0aGUgcmVkaXJlY3QgbWlnaHQgbGVhZCB0byBhIGRpZmZlcmVudCBob3N0XHJcbiAgdmFyIGN1cnJlbnRIb3N0SGVhZGVyID0gcmVtb3ZlTWF0Y2hpbmdIZWFkZXJzKC9eaG9zdCQvaSwgdGhpcy5fb3B0aW9ucy5oZWFkZXJzKTtcclxuXHJcbiAgLy8gSWYgdGhlIHJlZGlyZWN0IGlzIHJlbGF0aXZlLCBjYXJyeSBvdmVyIHRoZSBob3N0IG9mIHRoZSBsYXN0IHJlcXVlc3RcclxuICB2YXIgY3VycmVudFVybFBhcnRzID0gcGFyc2VVcmwodGhpcy5fY3VycmVudFVybCk7XHJcbiAgdmFyIGN1cnJlbnRIb3N0ID0gY3VycmVudEhvc3RIZWFkZXIgfHwgY3VycmVudFVybFBhcnRzLmhvc3Q7XHJcbiAgdmFyIGN1cnJlbnRVcmwgPSAvXlxcdys6Ly50ZXN0KGxvY2F0aW9uKSA/IHRoaXMuX2N1cnJlbnRVcmwgOlxyXG4gICAgdXJsLmZvcm1hdChPYmplY3QuYXNzaWduKGN1cnJlbnRVcmxQYXJ0cywgeyBob3N0OiBjdXJyZW50SG9zdCB9KSk7XHJcblxyXG4gIC8vIENyZWF0ZSB0aGUgcmVkaXJlY3RlZCByZXF1ZXN0XHJcbiAgdmFyIHJlZGlyZWN0VXJsID0gcmVzb2x2ZVVybChsb2NhdGlvbiwgY3VycmVudFVybCk7XHJcbiAgZGVidWcoXCJyZWRpcmVjdGluZyB0b1wiLCByZWRpcmVjdFVybC5ocmVmKTtcclxuICB0aGlzLl9pc1JlZGlyZWN0ID0gdHJ1ZTtcclxuICBzcHJlYWRVcmxPYmplY3QocmVkaXJlY3RVcmwsIHRoaXMuX29wdGlvbnMpO1xyXG5cclxuICAvLyBEcm9wIGNvbmZpZGVudGlhbCBoZWFkZXJzIHdoZW4gcmVkaXJlY3RpbmcgdG8gYSBsZXNzIHNlY3VyZSBwcm90b2NvbFxyXG4gIC8vIG9yIHRvIGEgZGlmZmVyZW50IGRvbWFpbiB0aGF0IGlzIG5vdCBhIHN1cGVyZG9tYWluXHJcbiAgaWYgKHJlZGlyZWN0VXJsLnByb3RvY29sICE9PSBjdXJyZW50VXJsUGFydHMucHJvdG9jb2wgJiZcclxuICAgICByZWRpcmVjdFVybC5wcm90b2NvbCAhPT0gXCJodHRwczpcIiB8fFxyXG4gICAgIHJlZGlyZWN0VXJsLmhvc3QgIT09IGN1cnJlbnRIb3N0ICYmXHJcbiAgICAgIWlzU3ViZG9tYWluKHJlZGlyZWN0VXJsLmhvc3QsIGN1cnJlbnRIb3N0KSkge1xyXG4gICAgcmVtb3ZlTWF0Y2hpbmdIZWFkZXJzKC9eKD86KD86cHJveHktKT9hdXRob3JpemF0aW9ufGNvb2tpZSkkL2ksIHRoaXMuX29wdGlvbnMuaGVhZGVycyk7XHJcbiAgfVxyXG5cclxuICAvLyBFdmFsdWF0ZSB0aGUgYmVmb3JlUmVkaXJlY3QgY2FsbGJhY2tcclxuICBpZiAoaXNGdW5jdGlvbihiZWZvcmVSZWRpcmVjdCkpIHtcclxuICAgIHZhciByZXNwb25zZURldGFpbHMgPSB7XHJcbiAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXHJcbiAgICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUsXHJcbiAgICB9O1xyXG4gICAgdmFyIHJlcXVlc3REZXRhaWxzID0ge1xyXG4gICAgICB1cmw6IGN1cnJlbnRVcmwsXHJcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxyXG4gICAgICBoZWFkZXJzOiByZXF1ZXN0SGVhZGVycyxcclxuICAgIH07XHJcbiAgICBiZWZvcmVSZWRpcmVjdCh0aGlzLl9vcHRpb25zLCByZXNwb25zZURldGFpbHMsIHJlcXVlc3REZXRhaWxzKTtcclxuICAgIHRoaXMuX3Nhbml0aXplT3B0aW9ucyh0aGlzLl9vcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8vIFBlcmZvcm0gdGhlIHJlZGlyZWN0ZWQgcmVxdWVzdFxyXG4gIHRoaXMuX3BlcmZvcm1SZXF1ZXN0KCk7XHJcbn07XHJcblxyXG4vLyBXcmFwcyB0aGUga2V5L3ZhbHVlIG9iamVjdCBvZiBwcm90b2NvbHMgd2l0aCByZWRpcmVjdCBmdW5jdGlvbmFsaXR5XHJcbmZ1bmN0aW9uIHdyYXAocHJvdG9jb2xzKSB7XHJcbiAgLy8gRGVmYXVsdCBzZXR0aW5nc1xyXG4gIHZhciBleHBvcnRzID0ge1xyXG4gICAgbWF4UmVkaXJlY3RzOiAyMSxcclxuICAgIG1heEJvZHlMZW5ndGg6IDEwICogMTAyNCAqIDEwMjQsXHJcbiAgfTtcclxuXHJcbiAgLy8gV3JhcCBlYWNoIHByb3RvY29sXHJcbiAgdmFyIG5hdGl2ZVByb3RvY29scyA9IHt9O1xyXG4gIE9iamVjdC5rZXlzKHByb3RvY29scykuZm9yRWFjaChmdW5jdGlvbiAoc2NoZW1lKSB7XHJcbiAgICB2YXIgcHJvdG9jb2wgPSBzY2hlbWUgKyBcIjpcIjtcclxuICAgIHZhciBuYXRpdmVQcm90b2NvbCA9IG5hdGl2ZVByb3RvY29sc1twcm90b2NvbF0gPSBwcm90b2NvbHNbc2NoZW1lXTtcclxuICAgIHZhciB3cmFwcGVkUHJvdG9jb2wgPSBleHBvcnRzW3NjaGVtZV0gPSBPYmplY3QuY3JlYXRlKG5hdGl2ZVByb3RvY29sKTtcclxuXHJcbiAgICAvLyBFeGVjdXRlcyBhIHJlcXVlc3QsIGZvbGxvd2luZyByZWRpcmVjdHNcclxuICAgIGZ1bmN0aW9uIHJlcXVlc3QoaW5wdXQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICAgIC8vIFBhcnNlIHBhcmFtZXRlcnMsIGVuc3VyaW5nIHRoYXQgaW5wdXQgaXMgYW4gb2JqZWN0XHJcbiAgICAgIGlmIChpc1VSTChpbnB1dCkpIHtcclxuICAgICAgICBpbnB1dCA9IHNwcmVhZFVybE9iamVjdChpbnB1dCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoaXNTdHJpbmcoaW5wdXQpKSB7XHJcbiAgICAgICAgaW5wdXQgPSBzcHJlYWRVcmxPYmplY3QocGFyc2VVcmwoaW5wdXQpKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XHJcbiAgICAgICAgb3B0aW9ucyA9IHZhbGlkYXRlVXJsKGlucHV0KTtcclxuICAgICAgICBpbnB1dCA9IHsgcHJvdG9jb2w6IHByb3RvY29sIH07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcclxuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XHJcbiAgICAgICAgb3B0aW9ucyA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNldCBkZWZhdWx0c1xyXG4gICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgbWF4UmVkaXJlY3RzOiBleHBvcnRzLm1heFJlZGlyZWN0cyxcclxuICAgICAgICBtYXhCb2R5TGVuZ3RoOiBleHBvcnRzLm1heEJvZHlMZW5ndGgsXHJcbiAgICAgIH0sIGlucHV0LCBvcHRpb25zKTtcclxuICAgICAgb3B0aW9ucy5uYXRpdmVQcm90b2NvbHMgPSBuYXRpdmVQcm90b2NvbHM7XHJcbiAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy5ob3N0KSAmJiAhaXNTdHJpbmcob3B0aW9ucy5ob3N0bmFtZSkpIHtcclxuICAgICAgICBvcHRpb25zLmhvc3RuYW1lID0gXCI6OjFcIjtcclxuICAgICAgfVxyXG5cclxuICAgICAgYXNzZXJ0LmVxdWFsKG9wdGlvbnMucHJvdG9jb2wsIHByb3RvY29sLCBcInByb3RvY29sIG1pc21hdGNoXCIpO1xyXG4gICAgICBkZWJ1ZyhcIm9wdGlvbnNcIiwgb3B0aW9ucyk7XHJcbiAgICAgIHJldHVybiBuZXcgUmVkaXJlY3RhYmxlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRXhlY3V0ZXMgYSBHRVQgcmVxdWVzdCwgZm9sbG93aW5nIHJlZGlyZWN0c1xyXG4gICAgZnVuY3Rpb24gZ2V0KGlucHV0LCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgICB2YXIgd3JhcHBlZFJlcXVlc3QgPSB3cmFwcGVkUHJvdG9jb2wucmVxdWVzdChpbnB1dCwgb3B0aW9ucywgY2FsbGJhY2spO1xyXG4gICAgICB3cmFwcGVkUmVxdWVzdC5lbmQoKTtcclxuICAgICAgcmV0dXJuIHdyYXBwZWRSZXF1ZXN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4cG9zZSB0aGUgcHJvcGVydGllcyBvbiB0aGUgd3JhcHBlZCBwcm90b2NvbFxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcHBlZFByb3RvY29sLCB7XHJcbiAgICAgIHJlcXVlc3Q6IHsgdmFsdWU6IHJlcXVlc3QsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcclxuICAgICAgZ2V0OiB7IHZhbHVlOiBnZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSxcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIHJldHVybiBleHBvcnRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub29wKCkgeyAvKiBlbXB0eSAqLyB9XHJcblxyXG5mdW5jdGlvbiBwYXJzZVVybChpbnB1dCkge1xyXG4gIHZhciBwYXJzZWQ7XHJcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICBpZiAodXNlTmF0aXZlVVJMKSB7XHJcbiAgICBwYXJzZWQgPSBuZXcgVVJMKGlucHV0KTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICAvLyBFbnN1cmUgdGhlIFVSTCBpcyB2YWxpZCBhbmQgYWJzb2x1dGVcclxuICAgIHBhcnNlZCA9IHZhbGlkYXRlVXJsKHVybC5wYXJzZShpbnB1dCkpO1xyXG4gICAgaWYgKCFpc1N0cmluZyhwYXJzZWQucHJvdG9jb2wpKSB7XHJcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVXJsRXJyb3IoeyBpbnB1dCB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHBhcnNlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZVVybChyZWxhdGl2ZSwgYmFzZSkge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgcmV0dXJuIHVzZU5hdGl2ZVVSTCA/IG5ldyBVUkwocmVsYXRpdmUsIGJhc2UpIDogcGFyc2VVcmwodXJsLnJlc29sdmUoYmFzZSwgcmVsYXRpdmUpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVVcmwoaW5wdXQpIHtcclxuICBpZiAoL15cXFsvLnRlc3QoaW5wdXQuaG9zdG5hbWUpICYmICEvXlxcW1s6MC05YS1mXStcXF0kL2kudGVzdChpbnB1dC5ob3N0bmFtZSkpIHtcclxuICAgIHRocm93IG5ldyBJbnZhbGlkVXJsRXJyb3IoeyBpbnB1dDogaW5wdXQuaHJlZiB8fCBpbnB1dCB9KTtcclxuICB9XHJcbiAgaWYgKC9eXFxbLy50ZXN0KGlucHV0Lmhvc3QpICYmICEvXlxcW1s6MC05YS1mXStcXF0oOlxcZCspPyQvaS50ZXN0KGlucHV0Lmhvc3QpKSB7XHJcbiAgICB0aHJvdyBuZXcgSW52YWxpZFVybEVycm9yKHsgaW5wdXQ6IGlucHV0LmhyZWYgfHwgaW5wdXQgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBpbnB1dDtcclxufVxyXG5cclxuZnVuY3Rpb24gc3ByZWFkVXJsT2JqZWN0KHVybE9iamVjdCwgdGFyZ2V0KSB7XHJcbiAgdmFyIHNwcmVhZCA9IHRhcmdldCB8fCB7fTtcclxuICBmb3IgKHZhciBrZXkgb2YgcHJlc2VydmVkVXJsRmllbGRzKSB7XHJcbiAgICBzcHJlYWRba2V5XSA9IHVybE9iamVjdFtrZXldO1xyXG4gIH1cclxuXHJcbiAgLy8gRml4IElQdjYgaG9zdG5hbWVcclxuICBpZiAoc3ByZWFkLmhvc3RuYW1lLnN0YXJ0c1dpdGgoXCJbXCIpKSB7XHJcbiAgICBzcHJlYWQuaG9zdG5hbWUgPSBzcHJlYWQuaG9zdG5hbWUuc2xpY2UoMSwgLTEpO1xyXG4gIH1cclxuICAvLyBFbnN1cmUgcG9ydCBpcyBhIG51bWJlclxyXG4gIGlmIChzcHJlYWQucG9ydCAhPT0gXCJcIikge1xyXG4gICAgc3ByZWFkLnBvcnQgPSBOdW1iZXIoc3ByZWFkLnBvcnQpO1xyXG4gIH1cclxuICAvLyBDb25jYXRlbmF0ZSBwYXRoXHJcbiAgc3ByZWFkLnBhdGggPSBzcHJlYWQuc2VhcmNoID8gc3ByZWFkLnBhdGhuYW1lICsgc3ByZWFkLnNlYXJjaCA6IHNwcmVhZC5wYXRobmFtZTtcclxuXHJcbiAgcmV0dXJuIHNwcmVhZDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlTWF0Y2hpbmdIZWFkZXJzKHJlZ2V4LCBoZWFkZXJzKSB7XHJcbiAgdmFyIGxhc3RWYWx1ZTtcclxuICBmb3IgKHZhciBoZWFkZXIgaW4gaGVhZGVycykge1xyXG4gICAgaWYgKHJlZ2V4LnRlc3QoaGVhZGVyKSkge1xyXG4gICAgICBsYXN0VmFsdWUgPSBoZWFkZXJzW2hlYWRlcl07XHJcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW2hlYWRlcl07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAobGFzdFZhbHVlID09PSBudWxsIHx8IHR5cGVvZiBsYXN0VmFsdWUgPT09IFwidW5kZWZpbmVkXCIpID9cclxuICAgIHVuZGVmaW5lZCA6IFN0cmluZyhsYXN0VmFsdWUpLnRyaW0oKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIGJhc2VDbGFzcykge1xyXG4gIC8vIENyZWF0ZSBjb25zdHJ1Y3RvclxyXG4gIGZ1bmN0aW9uIEN1c3RvbUVycm9yKHByb3BlcnRpZXMpIHtcclxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wZXJ0aWVzIHx8IHt9KTtcclxuICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmNhdXNlID8gbWVzc2FnZSArIFwiOiBcIiArIHRoaXMuY2F1c2UubWVzc2FnZSA6IG1lc3NhZ2U7XHJcbiAgfVxyXG5cclxuICAvLyBBdHRhY2ggY29uc3RydWN0b3IgYW5kIHNldCBkZWZhdWx0IHByb3BlcnRpZXNcclxuICBDdXN0b21FcnJvci5wcm90b3R5cGUgPSBuZXcgKGJhc2VDbGFzcyB8fCBFcnJvcikoKTtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDdXN0b21FcnJvci5wcm90b3R5cGUsIHtcclxuICAgIGNvbnN0cnVjdG9yOiB7XHJcbiAgICAgIHZhbHVlOiBDdXN0b21FcnJvcixcclxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICB9LFxyXG4gICAgbmFtZToge1xyXG4gICAgICB2YWx1ZTogXCJFcnJvciBbXCIgKyBjb2RlICsgXCJdXCIsXHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgfSxcclxuICB9KTtcclxuICByZXR1cm4gQ3VzdG9tRXJyb3I7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlc3Ryb3lSZXF1ZXN0KHJlcXVlc3QsIGVycm9yKSB7XHJcbiAgZm9yICh2YXIgZXZlbnQgb2YgZXZlbnRzKSB7XHJcbiAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBldmVudEhhbmRsZXJzW2V2ZW50XSk7XHJcbiAgfVxyXG4gIHJlcXVlc3Qub24oXCJlcnJvclwiLCBub29wKTtcclxuICByZXF1ZXN0LmRlc3Ryb3koZXJyb3IpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1N1YmRvbWFpbihzdWJkb21haW4sIGRvbWFpbikge1xyXG4gIGFzc2VydChpc1N0cmluZyhzdWJkb21haW4pICYmIGlzU3RyaW5nKGRvbWFpbikpO1xyXG4gIHZhciBkb3QgPSBzdWJkb21haW4ubGVuZ3RoIC0gZG9tYWluLmxlbmd0aCAtIDE7XHJcbiAgcmV0dXJuIGRvdCA+IDAgJiYgc3ViZG9tYWluW2RvdF0gPT09IFwiLlwiICYmIHN1YmRvbWFpbi5lbmRzV2l0aChkb21haW4pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbHVlKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAoXCJsZW5ndGhcIiBpbiB2YWx1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzVVJMKHZhbHVlKSB7XHJcbiAgcmV0dXJuIFVSTCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFVSTDtcclxufVxyXG5cclxuLy8gRXhwb3J0c1xyXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXAoeyBodHRwOiBodHRwLCBodHRwczogaHR0cHMgfSk7XHJcbm1vZHVsZS5leHBvcnRzLndyYXAgPSB3cmFwO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/follow-redirects/index.js\n");

/***/ })

};
;